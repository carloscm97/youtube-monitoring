{
  "dashboard": {
    "annotations": {
      "list": [
        {
          "builtIn": 1,
          "datasource": {
            "type": "grafana",
            "uid": "-- Grafana --"
          },
          "enable": true,
          "hide": true,
          "iconColor": "rgba(0, 211, 255, 1)",
          "name": "Annotations & Alerts",
          "target": {
            "limit": 100,
            "matchAny": false,
            "tags": [],
            "type": "dashboard"
          },
          "type": "dashboard"
        }
      ]
    },
    "editable": true,
    "fiscalYearStartMonth": 0,
    "graphTooltip": 0,
    "links": [
      {
        "asDropdown": false,
        "icon": "external link",
        "includeVars": false,
        "keepTime": false,
        "tags": [],
        "targetBlank": false,
        "title": "Navigate",
        "tooltip": "",
        "type": "dashboards",
        "url": ""
      }
    ],
    "liveNow": false,
    "panels": [
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 14,
          "w": 12,
          "x": 0,
          "y": 0
        },
        "id": 11,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'line'\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: true\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'video_title',\n  compact_series_text: true,\n  orientation: 'vertical',\n\n  legend: {\n    show: false,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  show_zeros: true,\n\n  stack: false,\n  selectedMode: true,\n  disable_emphasis: true,\n\n  parameters: [\n    {\n      name: 'view_count',\n      queryId: 'A',\n      legend: 'Daily Views ',\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 0.8,\n      intensity: '0.1',\n      type: 'line',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: false\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    },\n    {\n      name: 'video_title',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1,\n      width: 2.25\n    },\n    areaStyle: {\n    },\n    symbol: 'line',\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.endLabel = {\n        show: true,\n        formatter: function (params) {\n          return '{total|' + params.value[3] + ': ' + params.value[0] + '}';\n        },\n        rich: {\n          total: global_conf.label_text_format\n        }\n      };\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 0.75) * (series_name_list_aux.length - 0.75);\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 0.9) * (series_name_list_aux.length - 0.9);\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  animationDuration: 10000,\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_id,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name = '$channel_info__channel_name' AND\n  vi.video_id IN ($video_info__video_id) AND\n  $__timeFilter(vs.\"timestamp\")\nGROUP BY\n  vi.video_id,\n  day\n), cte_default AS (\nSELECT\n  *\nFROM\n  cte_video_list\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT DISTINCT\n  b.video_id,\n  gs.tag::DATE AS day,\n  0\nFROM\n  (SELECT generate_series (time_bucket('1 day', $__timeFrom()::timestamp with time zone), time_bucket('1 day', $__timeTo()::timestamp with time zone), '1 day') AS tag) gs,\n  cte_video_list b\nWHERE\n  gs.tag::DATE NOT IN (SELECT c.day FROM cte_video_list c WHERE b.video_id = c.video_id)\n), cte_partition AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day) AS value_partition_asc,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day DESC) AS value_partition_desc\nFROM\n  cte_default\n), cte_prepare_interpolation AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_date,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_date\nFROM\n  cte_partition\n), cte_interpolation AS (\nSELECT\n  vi.video_title,\n  TO_CHAR(cb.day, 'YYYY-MM-DD') AS day,\n  (CASE\n-- Linear interpolation\n    WHEN cb.first_next_not_null_value = 0 THEN cb.last_not_null_value\n    WHEN cb.last_not_null_value = 0 AND cb.day >= vi.video_creation_date::DATE\n      THEN cb.first_next_not_null_value/(cb.first_next_not_null_date - vi.video_creation_date::DATE) * (cb.day - vi.video_creation_date::DATE)\n    WHEN cb.last_not_null_value = 0 AND cb.day < vi.video_creation_date::DATE THEN 0\n    WHEN cb.view_count = 0 THEN cb.last_not_null_value + (cb.first_next_not_null_value - cb.last_not_null_value)/(cb.first_next_not_null_date - cb.last_not_null_date) * (cb.day - cb.last_not_null_date)\n    ELSE cb.view_count\n  END)::INTEGER AS view_count\nFROM\n  cte_prepare_interpolation cb\nINNER JOIN\n  youtube_stats.video_info vi \nON\n  cb.video_id = vi.video_id\n), cte_result AS (\nSELECT\n  video_title,\n  day,\n-- In case multiple videos have the same title or multiple values in a day\n  MAX(view_count) AS view_count\nFROM\n  cte_interpolation\nGROUP BY video_title, day\nORDER BY day ASC, view_count DESC\n)\nSELECT\n  video_title,\n  day,\n  view_count\nFROM\n  cte_result\nUNION ALL\nSELECT\n 'no_data' AS video_title,\n '2000-01-01' AS day,\n 0 AS view_count\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Dynamic View Count",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 14,
          "w": 12,
          "x": 12,
          "y": 0
        },
        "id": 12,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'line'\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: true\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'video_title',\n  compact_series_text: true,\n  orientation: 'vertical',\n\n  legend: {\n    show: false,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  show_zeros: true,\n\n  stack: false,\n  selectedMode: true,\n  disable_emphasis: true,\n\n  parameters: [\n    {\n      name: 'view_count',\n      queryId: 'A',\n      legend: 'Daily Views ',\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 0.8,\n      intensity: '0.1',\n      type: 'line',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: false\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    },\n    {\n      name: 'video_title',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1,\n      width: 2.25\n    },\n    areaStyle: {\n    },\n    symbol: 'line',\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.endLabel = {\n        show: true,\n        formatter: function (params) {\n          return '{total|' + params.value[3] + ': ' + params.value[0] + '}';\n        },\n        rich: {\n          total: global_conf.label_text_format\n        }\n      };\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 0.75) * (series_name_list_aux.length - 0.75);\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 0.9) * (series_name_list_aux.length - 0.9);\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  animationDuration: 10000,\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_id,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name = '$channel_info__channel_name_2' AND\n  vi.video_id IN ($video_info__video_id_2) AND\n  $__timeFilter(vs.\"timestamp\")\nGROUP BY\n  vi.video_id,\n  day\n), cte_default AS (\nSELECT\n  *\nFROM\n  cte_video_list\nUNION ALL\nSELECT DISTINCT\n  b.video_id,\n  gs.tag::DATE AS day,\n  0\nFROM\n  (SELECT generate_series (time_bucket('1 day', $__timeFrom()::timestamp with time zone), time_bucket('1 day', $__timeTo()::timestamp with time zone), '1 day') AS tag) gs,\n  cte_video_list b\nWHERE\n  gs.tag::DATE NOT IN (SELECT c.day FROM cte_video_list c WHERE b.video_id = c.video_id)\n), cte_partition AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day) AS value_partition_asc,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day DESC) AS value_partition_desc\nFROM\n  cte_default\n), cte_prepare_interpolation AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_date,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_date\nFROM\n  cte_partition\n), cte_interpolation AS (\nSELECT\n  vi.video_title,\n  TO_CHAR(cb.day, 'YYYY-MM-DD') AS day,\n  (CASE\n-- Linear interpolation\n    WHEN cb.first_next_not_null_value = 0 THEN cb.last_not_null_value\n    WHEN cb.last_not_null_value = 0 AND cb.day >= vi.video_creation_date::DATE\n      THEN cb.first_next_not_null_value/(cb.first_next_not_null_date - vi.video_creation_date::DATE) * (cb.day - vi.video_creation_date::DATE)\n    WHEN cb.last_not_null_value = 0 AND cb.day < vi.video_creation_date::DATE THEN 0\n    WHEN cb.view_count = 0 THEN cb.last_not_null_value + (cb.first_next_not_null_value - cb.last_not_null_value)/(cb.first_next_not_null_date - cb.last_not_null_date) * (cb.day - cb.last_not_null_date)\n    ELSE cb.view_count\n  END)::INTEGER AS view_count\nFROM\n  cte_prepare_interpolation cb\nINNER JOIN\n  youtube_stats.video_info vi \nON\n  cb.video_id = vi.video_id\n), cte_result AS (\nSELECT\n  video_title,\n  day,\n-- In case multiple videos have the same title or multiple values in a day\n  MAX(view_count) AS view_count\nFROM\n  cte_interpolation\nGROUP BY video_title, day\nORDER BY day ASC, view_count DESC\n)\nSELECT\n  video_title,\n  day,\n  view_count\nFROM\n  cte_result\nUNION ALL\nSELECT\n 'no_data' AS video_title,\n '2000-01-01' AS day,\n 0 AS view_count\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Dynamic View Count",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 15,
          "w": 12,
          "x": 0,
          "y": 14
        },
        "id": 5,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'cross'\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: true\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'video_title',\n  compact_series_text: true,\n  orientation: 'vertical',\n\n  legend: {\n    show: false,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  show_zeros: true,\n\n  stack: false,\n  selectedMode: true,\n  disable_emphasis: true,\n\n  parameters: [\n    {\n      name: 'daily_views',\n      queryId: 'A',\n      legend: 'Daily Views ',\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 0.8,\n      intensity: '0.2',\n      type: 'line',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: false\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    },\n    {\n      name: 'video_title',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1,\n      width: 2.25\n    },\n    areaStyle: {\n    },\n    symbol: 'line',\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 0.75) * (series_name_list_aux.length - 0.75);\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 0.9) * (series_name_list_aux.length - 0.9);\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_title,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name = '$channel_info__channel_name' AND\n  vi.video_id IN ($video_info__video_id) AND\n  vs.\"timestamp\" >= ($__timeFrom()::timestamp with time zone - INTERVAL '7 days') AND\n  vs.\"timestamp\" <= $__timeTo()::timestamp with time zone\nGROUP BY\n  vi.video_title,\n  day\n), cte_lag AS (\nSELECT\n  ct.day,\n  ct.video_title,\n  ct.view_count,\n  LAG(ct.view_count, -1) OVER w AS last_view_count,\n  LAG(ct.day, -1) OVER w AS last_day\nFROM\n  cte_video_list ct\nWINDOW w AS (PARTITION BY ct.video_title ORDER BY ct.day DESC)\n), cte_daily_views AS (\nSELECT\n  cl.video_title,\n  (cl.view_count - cl.last_view_count)/(cl.day - cl.last_day) AS daily_views,\n  generate_series(\n-- First day is not taken into account as it is part of the previous window.\n\t  cl.last_day + INTERVAL '1 day',\n    cl.day, INTERVAL '1 day'\n  ) AS day\nFROM\n  cte_lag cl\nWHERE\n  cl.last_view_count IS NOT NULL\n), cte_result AS (\nSELECT\n  video_title,\n  AVG(daily_views) AS daily_views,\n  TO_CHAR(day,'YYYY-MM-DD') AS day\nFROM\n  cte_daily_views\nGROUP BY\n  video_title, day\nORDER BY\n  day, daily_views DESC\n)\nSELECT\n  video_title,\n  daily_views,\n  day\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n 'no_data' AS video_title,\n 0 AS daily_views,\n '2000-01-01' AS day\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Daily View Count",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 15,
          "w": 12,
          "x": 12,
          "y": 14
        },
        "id": 6,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'cross'\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: true\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'video_title',\n  compact_series_text: true,\n  orientation: 'vertical',\n\n  legend: {\n    show: false,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  show_zeros: true,\n\n  stack: false,\n  selectedMode: true,\n  disable_emphasis: true,\n\n  parameters: [\n    {\n      name: 'daily_views',\n      queryId: 'A',\n      legend: 'Daily Views ',\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 0.8,\n      intensity: '0.2',\n      type: 'line',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: false\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    },\n    {\n      name: 'video_title',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1,\n      width: 2.25\n    },\n    areaStyle: {\n    },\n    symbol: 'line',\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 0.75) * (series_name_list_aux.length - 0.75);\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 0.9) * (series_name_list_aux.length - 0.9);\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_title,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name = '$channel_info__channel_name_2' AND\n  vi.video_id IN ($video_info__video_id_2) AND\n  $__timeFilter(vs.\"timestamp\")\nGROUP BY\n  vi.video_title,\n  day\n), cte_lag AS (\nSELECT\n  ct.day,\n  ct.video_title,\n  ct.view_count,\n  LAG(ct.view_count, -1) OVER w AS last_view_count,\n  LAG(ct.day, -1) OVER w AS last_day\nFROM\n  cte_video_list ct\nWINDOW w AS (PARTITION BY ct.video_title ORDER BY ct.day DESC)\n), cte_daily_views AS (\nSELECT\n  cl.video_title,\n  (cl.view_count - cl.last_view_count)/(cl.day - cl.last_day) AS daily_views,\n  generate_series(\n-- First day is not taken into account as it is part of the previous window.\n\t  cl.last_day + INTERVAL '1 day',\n    cl.day, INTERVAL '1 day'\n  ) AS day\nFROM\n  cte_lag cl\nWHERE\n  cl.last_view_count IS NOT NULL\n), cte_result AS (\nSELECT\n  video_title,\n  AVG(daily_views) AS daily_views,\n  TO_CHAR(day,'YYYY-MM-DD') AS day\nFROM\n  cte_daily_views\nGROUP BY\n  video_title, day\nORDER BY\n  day, daily_views DESC\n)\nSELECT\n  video_title,\n  daily_views,\n  day\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n 'no_data' AS video_title,\n 0 AS daily_views,\n '2000-01-01' AS day\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Daily View Count",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 19,
          "w": 12,
          "x": 0,
          "y": 29
        },
        "id": 9,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'shadow'\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: false\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'video_title',\n  orientation: 'horizontal',\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n\n  parameter: {\n    name: 'view_count',\n    queryId: 'A',\n    legend: 'Daily Views ',\n    color: ['rgb(216, 124, 124)', 'rgb(145, 158, 139)', 'rgb(215, 171, 130)', 'rgb(110, 112, 116)', 'rgb(97, 160, 168)', 'rgb(239, 161, 141)', 'rgb(120, 116, 100)', 'rgb(204, 126, 99)', 'rgb(114, 78, 88)', 'rgb(75, 86, 91)'], color_gradient: true,\n    color_gradient_diff: 30,\n    color_gradient_start: 0.8,\n    intensity: '0.7',\n    scale_reduction: 1.1\n  },\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    axisLine: {\n      show: false\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    inverse: true,\n    axisLabel: {\n      show: false,\n      fontSize: 0,\n    },\n    animationDuration: 300,\n    animationDurationUpdate: 300\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    axisLine: {\n      show: false\n    },\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    inverse: true,\n    axisLabel: {\n      show: false,\n      fontSize: 0,\n    },\n    animationDuration: 300,\n    animationDurationUpdate: 300\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    /* Calculates the exp of the power base 10 as a function of the value */\n    let length = (\"\" + parseInt(value.max * scale_reduction)).length;\n    let pow = 0;\n    if (length < 1) {\n      pow = Math.floor(length);\n    } else if (length < 2) {\n      pow = Math.floor(length) - 1;\n    } else {\n      pow = Math.floor(length) - 2;\n    }\n\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  if (value.min < value.max * 0.05) {\n    let pow = parseInt(value.min).toString().length - 1\n    return Math.floor(-value.max * 0.1 / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    if (!!global_conf.value_axis.scale_min) {\n      /* Calculates the exponential of the power base 10 as a function of the value */\n      let pow = parseInt(value.min).toString().length - 1\n\n      return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {};\nconst data = context.panel.data;\ndata.series.map((s) => {\n  if (global_conf.parameter.queryId === s.refId) {\n    raw_data[global_conf.parameter.name] = s.fields.find((f) => (f.name === global_conf.parameter.name && s.refId === global_conf.parameter.queryId)).values;\n    raw_data[global_conf.time_reference] = s.fields.find((f) => (f.name === global_conf.time_reference && s.refId === global_conf.parameter.queryId)).values;\n    raw_data[global_conf.series_reference] = s.fields.find((f) => (f.name === global_conf.series_reference && s.refId === global_conf.parameter.queryId)).values.map(String);\n  }\n});\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nfor (const parameter in raw_data) {\n  if (raw_data[parameter].length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nlet processed_data = {};\nraw_data[global_conf.time_reference].map((time, time_index) => {\n  let pair_aux = [0, 0];\n  pair_aux[value_index] = Math.round(raw_data[global_conf.parameter.name][time_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n  pair_aux[category_index] = raw_data[global_conf.series_reference][time_index];\n  if (!(time in processed_data)) {\n    processed_data[time] = []\n  }\n  processed_data[time].push(pair_aux);\n});\n\nif (global_conf.orientation == 'horizontal') {\n  xAxis.push({\n    name: global_conf.parameter.legend,\n    nameTextStyle: {\n      /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n      color: 'rgb(0,0,0,0)'\n    },\n    show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n    type: 'value',\n    max: function (value) { return getMax(value, global_conf.parameter.scale_reduction) },\n    min: function (value) { return getMin(value) },\n    splitLine: {\n      show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n    },\n    axisLabel: {\n      formatter: function (value, index) {\n        return numberFormat(value);\n      },\n      color: 'rgb(40, 50, 60, 0.8)'\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n} else {\n  yAxis.push({\n    name: global_conf.parameter.legend,\n    nameTextStyle: {\n      /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n      color: 'rgb(0,0,0,0)'\n    },\n    show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n    type: 'value',\n    max: function (value) { return getMax(value, global_conf.parameter.scale_reduction) },\n    min: function (value) { return getMin(value) },\n    splitLine: {\n      show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n    },\n    axisLabel: {\n      formatter: function (value, index) {\n        return numberFormat(value);\n      },\n      color: 'rgb(40, 50, 60, 0.8)'\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n}\n\nconst updateFrequency = 2000;\nlet times_set = Array.from([...new Set(raw_data[global_conf.time_reference])]).sort(compareInterval);\nlet series_set = [...new Set(raw_data[global_conf.series_reference])];\nlet graphics = {\n  elements: [\n    {\n      type: 'text',\n      right: 160,\n      bottom: 60,\n      style: {\n        text: times_set[0][1],\n        font: 'bolder 80px monospace',\n        fill: 'rgba(100, 100, 100, 0.25)'\n      },\n      z: 0\n    }\n  ]\n};\nlet serie = [\n  {\n    realtimeSort: true,\n    stack: 'stack',\n    seriesLayoutBy: 'column',\n    type: 'bar',\n    data: processed_data[times_set[0]],\n    label: {\n      show: true,\n      precision: 0,\n      valueAnimation: true,\n      fontFamily: 'monospace',\n      normal: {\n        show: true,\n        valueAnimation: true,\n        position: (global_conf.orientation == 'vertical') ? 'top' : 'right',\n        formatter: (params) => {\n          return '{total|' + numberFormat(params.value[value_index]) + '}';\n        },\n        rich: {\n          total: global_conf.label_text_format\n        }\n      }\n    },\n    itemStyle: {\n      color: function (param) {\n        let color = global_conf.parameter.color[series_set.indexOf(param.name) % global_conf.parameter.color.length];\n        let color_light = rgbLight(color, global_conf.parameter.color_gradient_diff, global_conf.parameter.intensity);\n        let color_dark = rgbDark(color, global_conf.parameter.color_gradient_diff, global_conf.parameter.intensity);\n        return {\n          type: 'linear',\n          x: 0,\n          y: 0,\n          x2: (global_conf.orientation == 'vertical') ? 0 : 1,\n          y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n          global: false,\n          colorStops: [\n            {\n              offset: 0,\n              color: color_light\n            },\n            {\n              offset: global_conf.parameter.color_gradient_start,\n              color: color_dark\n            }\n          ]\n        };\n      }\n    },\n    z: 10,\n    labelLayout: { hideoverlap: true }\n  }, {\n    realtimeSort: true,\n    stack: 'stack',\n    seriesLayoutBy: 'column',\n    type: 'bar',\n    itemStyle: {\n      color: 'rgb(255, 255, 255, 0)',\n      borderColor: 'rgb(255, 255, 255, 0)',\n      shadowColor: 'rgb(255, 255, 255, 0)'\n    },\n    lineStyle: {\n      color: 'rgb(255, 255, 255, 0)',\n      shadowColor: 'rgb(255, 255, 255, 0)',\n    },\n    data: processed_data[times_set[0]],\n    label: {\n      show: true,\n      precision: 0,\n      position: (global_conf.orientation == 'horizontal') ? 'left' : 'bottom',\n      distance: 10,\n      padding: [0, 0, 0, 0],\n      formatter: function (d) {\n        name_split = d.name.split(/\\s+/);\n        mid_element = Math.floor(name_split.length - 1);\n        if (name_split.length > 1 && d.name.length > 6) {\n          str_output = '';\n          i_aux = 0;\n          if (d.name.length < 20) {\n            // Intentar que al partir por la mitad el texto el de arriba no sea muy largo o viceversa\n            mid_length = Math.floor((d.name.length - 1) / 2);\n            while ((str_output.length + Math.floor(name_split[i_aux].length / 2)) <= mid_length) {\n              str_output += name_split[i_aux] + ' ';\n              i_aux += 1;\n            }\n            str_output += '\\n';\n            for (let i = i_aux; i < name_split.length; ++i) {\n              str_output += name_split[i] + ' '\n            }\n            rich_output = 'name';\n          } else {\n            third_length = Math.floor((d.name.length - 1) / 3);\n            while ((str_output.length + Math.floor(name_split[i_aux].length / 2)) <= third_length) {\n              str_output += name_split[i_aux] + ' ';\n              i_aux += 1;\n            }\n            str_output += '\\n';\n            while ((str_output.length + Math.floor(name_split[i_aux].length / 2)) <= 2 * third_length) {\n              str_output += name_split[i_aux] + ' ';\n              i_aux += 1;\n            }\n            str_output += '\\n';\n            for (let i = i_aux; i < name_split.length; ++i) {\n              str_output += name_split[i] + ' '\n            }\n            rich_output = 'name_small';\n          }\n        } else {\n          str_output = d.name\n          rich_output = 'name';\n        }\n        return `{${rich_output}|${str_output}}`;\n      },\n      rich: {\n        name: {\n          fontFamily: 'Trebuchet MS',\n          fontSize: 17,\n          verticalAlign: 'top',\n          textBorderWidth: 0,\n          color: '#ffffff',\n          fontWeight: \"bold\"\n        },\n        name_small: {\n          fontFamily: 'Trebuchet MS',\n          fontSize: 13,\n          verticalAlign: 'top',\n          textBorderWidth: 0,\n          color: '#ffffff',\n          fontWeight: \"bold\"\n        }\n      }\n    },\n    z: 10\n  }\n];\noption = {\n  grid: {\n    top: '4%',\n    bottom: '7%',\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  },\n  xAxis: xAxis,\n  yAxis: yAxis,\n  series: serie,\n  tooltip: {\n    trigger: 'axis',\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      return `${params[0].marker}<span style=\"font-size:15px\">${params[0].value[category_index]}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params[0].value[value_index])}</span>`;\n    }),\n    axisPointer: {\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n  // Disable init animation.\n  animationDuration: 0,\n  animationDurationUpdate: updateFrequency,\n  animationEasing: 'linear',\n  animationEasingUpdate: 'linear',\n  graphic: graphics\n};\n\nfor (const [time_index, time] of times_set.entries()) {\n  (function (time_index) {\n    setTimeout(function () {\n      graphics.elements[0].style.text = time;\n      serie[0].data = processed_data[time];\n      serie[1].data = processed_data[time];\n      context.panel.chart.setOption({\n        series: serie,\n        graphic: graphics\n      });\n    }, updateFrequency * time_index)\n  })(time_index);\n}\n\nreturn option;",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_id,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name = '$channel_info__channel_name' AND\n  vi.video_id IN ($video_info__video_id) AND\n  $__timeFilter(vs.\"timestamp\")\nGROUP BY\n  vi.video_id,\n  day\n), cte_default AS (\nSELECT\n  *\nFROM\n  cte_video_list\nUNION ALL\nSELECT DISTINCT\n  b.video_id,\n  gs.tag::DATE AS day,\n  0\nFROM\n  (SELECT generate_series (time_bucket('1 day', $__timeFrom()::timestamp with time zone), time_bucket('1 day', $__timeTo()::timestamp with time zone), '1 day') AS tag) gs,\n  cte_video_list b\nWHERE\n  gs.tag::DATE NOT IN (SELECT c.day FROM cte_video_list c WHERE b.video_id = c.video_id)\n), cte_partition AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day) AS value_partition_asc,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day DESC) AS value_partition_desc\nFROM\n  cte_default\n), cte_prepare_interpolation AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_date,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_date\nFROM\n  cte_partition\n), cte_interpolation AS (\nSELECT\n  vi.video_title,\n  TO_CHAR(cb.day, 'YYYY-MM-DD') AS day,\n-- Linear interpolation\n  (CASE\n    WHEN cb.first_next_not_null_value = 0 THEN cb.last_not_null_value\n    WHEN cb.last_not_null_value = 0 AND cb.day >= vi.video_creation_date::DATE\n      THEN cb.first_next_not_null_value/(cb.first_next_not_null_date - vi.video_creation_date::DATE) * (cb.day - vi.video_creation_date::DATE)\n    WHEN cb.last_not_null_value = 0 AND cb.day < vi.video_creation_date::DATE THEN 0\n    WHEN cb.view_count = 0 THEN cb.last_not_null_value + (cb.first_next_not_null_value - cb.last_not_null_value)/(cb.first_next_not_null_date - cb.last_not_null_date) * (cb.day - cb.last_not_null_date)\n    ELSE cb.view_count\n  END)::INTEGER AS view_count\nFROM\n  cte_prepare_interpolation cb\nINNER JOIN\n  youtube_stats.video_info vi \nON\n  cb.video_id = vi.video_id\n), cte_result AS (\nSELECT\n  video_title,\n  day,\n-- In case multiple videos have the same title or multiple values in a day\n  MAX(view_count) AS view_count\nFROM\n  cte_interpolation\nGROUP BY video_title, day\nORDER BY day ASC, view_count DESC\n)\nSELECT\n  video_title,\n  day,\n  view_count\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n 'no_data' AS video_title,\n '2000-01-01' AS day,\n 0 AS view_count\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Dynamic View Count",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 19,
          "w": 12,
          "x": 12,
          "y": 29
        },
        "id": 10,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'shadow'\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: false\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'video_title',\n  orientation: 'horizontal',\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n\n  parameter: {\n    name: 'view_count',\n    queryId: 'A',\n    legend: 'Daily Views ',\n    color: ['rgb(216, 124, 124)', 'rgb(145, 158, 139)', 'rgb(215, 171, 130)', 'rgb(110, 112, 116)', 'rgb(97, 160, 168)', 'rgb(239, 161, 141)', 'rgb(120, 116, 100)', 'rgb(204, 126, 99)', 'rgb(114, 78, 88)', 'rgb(75, 86, 91)'], color_gradient: true,\n    color_gradient_diff: 30,\n    color_gradient_start: 0.8,\n    intensity: '0.7',\n    scale_reduction: 1.1\n  },\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    axisLine: {\n      show: false\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    inverse: true,\n    axisLabel: {\n      show: false,\n      fontSize: 0,\n    },\n    animationDuration: 300,\n    animationDurationUpdate: 300\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    axisLine: {\n      show: false\n    },\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    inverse: true,\n    axisLabel: {\n      show: false,\n      fontSize: 0,\n    },\n    animationDuration: 300,\n    animationDurationUpdate: 300\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    /* Calculates the exp of the power base 10 as a function of the value */\n    let length = (\"\" + parseInt(value.max * scale_reduction)).length;\n    let pow = 0;\n    if (length < 1) {\n      pow = Math.floor(length);\n    } else if (length < 2) {\n      pow = Math.floor(length) - 1;\n    } else {\n      pow = Math.floor(length) - 2;\n    }\n\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  if (value.min < value.max * 0.05) {\n    let pow = parseInt(value.min).toString().length - 1\n    return Math.floor(-value.max * 0.1 / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    if (!!global_conf.value_axis.scale_min) {\n      /* Calculates the exponential of the power base 10 as a function of the value */\n      let pow = parseInt(value.min).toString().length - 1\n\n      return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {};\nconst data = context.panel.data;\ndata.series.map((s) => {\n  if (global_conf.parameter.queryId === s.refId) {\n    raw_data[global_conf.parameter.name] = s.fields.find((f) => (f.name === global_conf.parameter.name && s.refId === global_conf.parameter.queryId)).values;\n    raw_data[global_conf.time_reference] = s.fields.find((f) => (f.name === global_conf.time_reference && s.refId === global_conf.parameter.queryId)).values;\n    raw_data[global_conf.series_reference] = s.fields.find((f) => (f.name === global_conf.series_reference && s.refId === global_conf.parameter.queryId)).values.map(String);\n  }\n});\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nfor (const parameter in raw_data) {\n  if (raw_data[parameter].length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nlet processed_data = {};\nraw_data[global_conf.time_reference].map((time, time_index) => {\n  let pair_aux = [0, 0];\n  pair_aux[value_index] = Math.round(raw_data[global_conf.parameter.name][time_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n  pair_aux[category_index] = raw_data[global_conf.series_reference][time_index];\n  if (!(time in processed_data)) {\n    processed_data[time] = []\n  }\n  processed_data[time].push(pair_aux);\n});\n\nif (global_conf.orientation == 'horizontal') {\n  xAxis.push({\n    name: global_conf.parameter.legend,\n    nameTextStyle: {\n      /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n      color: 'rgb(0,0,0,0)'\n    },\n    show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n    type: 'value',\n    max: function (value) { return getMax(value, global_conf.parameter.scale_reduction) },\n    min: function (value) { return getMin(value) },\n    splitLine: {\n      show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n    },\n    axisLabel: {\n      formatter: function (value, index) {\n        return numberFormat(value);\n      },\n      color: 'rgb(40, 50, 60, 0.8)'\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n} else {\n  yAxis.push({\n    name: global_conf.parameter.legend,\n    nameTextStyle: {\n      /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n      color: 'rgb(0,0,0,0)'\n    },\n    show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n    type: 'value',\n    max: function (value) { return getMax(value, global_conf.parameter.scale_reduction) },\n    min: function (value) { return getMin(value) },\n    splitLine: {\n      show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n    },\n    axisLabel: {\n      formatter: function (value, index) {\n        return numberFormat(value);\n      },\n      color: 'rgb(40, 50, 60, 0.8)'\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n}\n\nconst updateFrequency = 2000;\nlet times_set = Array.from([...new Set(raw_data[global_conf.time_reference])]).sort(compareInterval);\nlet series_set = [...new Set(raw_data[global_conf.series_reference])];\nlet graphics = {\n  elements: [\n    {\n      type: 'text',\n      right: 160,\n      bottom: 60,\n      style: {\n        text: times_set[0][1],\n        font: 'bolder 80px monospace',\n        fill: 'rgba(100, 100, 100, 0.25)'\n      },\n      z: 0\n    }\n  ]\n};\nlet serie = [\n  {\n    realtimeSort: true,\n    stack: 'stack',\n    seriesLayoutBy: 'column',\n    type: 'bar',\n    data: processed_data[times_set[0]],\n    label: {\n      show: true,\n      precision: 0,\n      valueAnimation: true,\n      fontFamily: 'monospace',\n      normal: {\n        show: true,\n        valueAnimation: true,\n        position: (global_conf.orientation == 'vertical') ? 'top' : 'right',\n        formatter: (params) => {\n          return '{total|' + numberFormat(params.value[value_index]) + '}';\n        },\n        rich: {\n          total: global_conf.label_text_format\n        }\n      }\n    },\n    itemStyle: {\n      color: function (param) {\n        let color = global_conf.parameter.color[series_set.indexOf(param.name) % global_conf.parameter.color.length];\n        let color_light = rgbLight(color, global_conf.parameter.color_gradient_diff, global_conf.parameter.intensity);\n        let color_dark = rgbDark(color, global_conf.parameter.color_gradient_diff, global_conf.parameter.intensity);\n        return {\n          type: 'linear',\n          x: 0,\n          y: 0,\n          x2: (global_conf.orientation == 'vertical') ? 0 : 1,\n          y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n          global: false,\n          colorStops: [\n            {\n              offset: 0,\n              color: color_light\n            },\n            {\n              offset: global_conf.parameter.color_gradient_start,\n              color: color_dark\n            }\n          ]\n        };\n      }\n    },\n    z: 10,\n    labelLayout: { hideoverlap: true }\n  }, {\n    realtimeSort: true,\n    stack: 'stack',\n    seriesLayoutBy: 'column',\n    type: 'bar',\n    itemStyle: {\n      color: 'rgb(255, 255, 255, 0)',\n      borderColor: 'rgb(255, 255, 255, 0)',\n      shadowColor: 'rgb(255, 255, 255, 0)'\n    },\n    lineStyle: {\n      color: 'rgb(255, 255, 255, 0)',\n      shadowColor: 'rgb(255, 255, 255, 0)',\n    },\n    data: processed_data[times_set[0]],\n    label: {\n      show: true,\n      precision: 0,\n      position: (global_conf.orientation == 'horizontal') ? 'left' : 'bottom',\n      distance: 10,\n      padding: [0, 0, 0, 0],\n      formatter: function (d) {\n        name_split = d.name.split(/\\s+/);\n        mid_element = Math.floor(name_split.length - 1);\n        if (name_split.length > 1 && d.name.length > 6) {\n          str_output = '';\n          i_aux = 0;\n          if (d.name.length < 20) {\n            // Intentar que al partir por la mitad el texto el de arriba no sea muy largo o viceversa\n            mid_length = Math.floor((d.name.length - 1) / 2);\n            while ((str_output.length + Math.floor(name_split[i_aux].length / 2)) <= mid_length) {\n              str_output += name_split[i_aux] + ' ';\n              i_aux += 1;\n            }\n            str_output += '\\n';\n            for (let i = i_aux; i < name_split.length; ++i) {\n              str_output += name_split[i] + ' '\n            }\n            rich_output = 'name';\n          } else {\n            third_length = Math.floor((d.name.length - 1) / 3);\n            while ((str_output.length + Math.floor(name_split[i_aux].length / 2)) <= third_length) {\n              str_output += name_split[i_aux] + ' ';\n              i_aux += 1;\n            }\n            str_output += '\\n';\n            while ((str_output.length + Math.floor(name_split[i_aux].length / 2)) <= 2 * third_length) {\n              str_output += name_split[i_aux] + ' ';\n              i_aux += 1;\n            }\n            str_output += '\\n';\n            for (let i = i_aux; i < name_split.length; ++i) {\n              str_output += name_split[i] + ' '\n            }\n            rich_output = 'name_small';\n          }\n        } else {\n          str_output = d.name\n          rich_output = 'name';\n        }\n        return `{${rich_output}|${str_output}}`;\n      },\n      rich: {\n        name: {\n          fontFamily: 'Trebuchet MS',\n          fontSize: 17,\n          verticalAlign: 'top',\n          textBorderWidth: 0,\n          color: '#ffffff',\n          fontWeight: \"bold\"\n        },\n        name_small: {\n          fontFamily: 'Trebuchet MS',\n          fontSize: 13,\n          verticalAlign: 'top',\n          textBorderWidth: 0,\n          color: '#ffffff',\n          fontWeight: \"bold\"\n        }\n      }\n    },\n    z: 10\n  }\n];\noption = {\n  grid: {\n    top: '4%',\n    bottom: '7%',\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  },\n  xAxis: xAxis,\n  yAxis: yAxis,\n  series: serie,\n  tooltip: {\n    trigger: 'axis',\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      return `${params[0].marker}<span style=\"font-size:15px\">${params[0].value[category_index]}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params[0].value[value_index])}</span>`;\n    }),\n    axisPointer: {\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n  // Disable init animation.\n  animationDuration: 0,\n  animationDurationUpdate: updateFrequency,\n  animationEasing: 'linear',\n  animationEasingUpdate: 'linear',\n  graphic: graphics\n};\n\nfor (const [time_index, time] of times_set.entries()) {\n  (function (time_index) {\n    setTimeout(function () {\n      graphics.elements[0].style.text = time;\n      serie[0].data = processed_data[time];\n      serie[1].data = processed_data[time];\n      context.panel.chart.setOption({\n        series: serie,\n        graphic: graphics\n      });\n    }, updateFrequency * time_index)\n  })(time_index);\n}\n\nreturn option;",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_id,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name = '$channel_info__channel_name_2' AND\n  vi.video_id IN ($video_info__video_id_2) AND\n  $__timeFilter(vs.\"timestamp\")\nGROUP BY\n  vi.video_id,\n  day\n), cte_default AS (\nSELECT\n  *\nFROM\n  cte_video_list\nUNION ALL\nSELECT DISTINCT\n  b.video_id,\n  gs.tag::DATE AS day,\n  0\nFROM\n  (SELECT generate_series (time_bucket('1 day', $__timeFrom()::timestamp with time zone), time_bucket('1 day', $__timeTo()::timestamp with time zone), '1 day') AS tag) gs,\n  cte_video_list b\nWHERE\n  gs.tag::DATE NOT IN (SELECT c.day FROM cte_video_list c WHERE b.video_id = c.video_id)\n), cte_partition AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day) AS value_partition_asc,\n  SUM(CASE WHEN view_count <> 0 THEN 1 ELSE 0 END) OVER (PARTITION BY video_id ORDER BY day DESC) AS value_partition_desc\nFROM\n  cte_default\n), cte_prepare_interpolation AS (\nSELECT\n  video_id,\n  day,\n  view_count,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_asc ORDER BY day) AS last_not_null_date,\n  FIRST_VALUE(view_count) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_value,\n  FIRST_VALUE(day) OVER (PARTITION BY video_id, value_partition_desc ORDER BY day DESC) AS first_next_not_null_date\nFROM\n  cte_partition\n), cte_interpolation AS (\nSELECT\n  vi.video_title,\n  TO_CHAR(cb.day, 'YYYY-MM-DD') AS day,\n-- Linear interpolation\n  (CASE\n    WHEN cb.first_next_not_null_value = 0 THEN cb.last_not_null_value\n    WHEN cb.last_not_null_value = 0 AND cb.day >= vi.video_creation_date::DATE\n      THEN cb.first_next_not_null_value/(cb.first_next_not_null_date - vi.video_creation_date::DATE) * (cb.day - vi.video_creation_date::DATE)\n    WHEN cb.last_not_null_value = 0 AND cb.day < vi.video_creation_date::DATE THEN 0\n    WHEN cb.view_count = 0 THEN cb.last_not_null_value + (cb.first_next_not_null_value - cb.last_not_null_value)/(cb.first_next_not_null_date - cb.last_not_null_date) * (cb.day - cb.last_not_null_date)\n    ELSE cb.view_count\n  END)::INTEGER AS view_count\nFROM\n  cte_prepare_interpolation cb\nINNER JOIN\n  youtube_stats.video_info vi \nON\n  cb.video_id = vi.video_id\n), cte_result AS (\nSELECT\n  video_title,\n  day,\n-- In case multiple videos have the same title or multiple values in a day\n  MAX(view_count) AS view_count\nFROM\n  cte_interpolation\nGROUP BY video_title, day\nORDER BY day ASC, view_count DESC\n)\nSELECT\n  video_title,\n  day,\n  view_count\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n 'no_data' AS video_title,\n '2000-01-01' AS day,\n 0 AS view_count\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Dynamic Daily Views",
        "type": "volkovlabs-echarts-panel"
      }
    ],
    "schemaVersion": 39,
    "tags": [
      "youtube",
      "videos"
    ],
    "templating": {
      "list": [
        {
          "current": {
            "selected": false,
            "text": "Shakira",
            "value": "Shakira"
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_channel_name AS (\nSELECT\n  channel_name\nFROM\n  youtube_stats.channel_info\nORDER BY\n  channel_name ASC\n)\nSELECT\n  channel_name\nFROM\n  cte_channel_name\nUNION ALL\nSELECT\n 'no data' AS channel_name\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_name b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_name)",
          "hide": 0,
          "includeAll": false,
          "label": "Channel Name",
          "multi": false,
          "name": "channel_info__channel_name",
          "options": [],
          "query": "WITH cte_channel_name AS (\nSELECT\n  channel_name\nFROM\n  youtube_stats.channel_info\nORDER BY\n  channel_name ASC\n)\nSELECT\n  channel_name\nFROM\n  cte_channel_name\nUNION ALL\nSELECT\n 'no data' AS channel_name\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_name b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_name)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": true,
            "text": [
              "Shakira - Cómo Dónde y Cuándo (Audio)",
              "Shakira - Nassau (Audio)",
              "Shakira - Tiempo Sin Verte (Audio)",
              "Shakira - Última (Audio)",
              "Shakira, Bizarrap - La Fuerte (Audio)"
            ],
            "value": [
              "Shakira - Cómo Dónde y Cuándo (Audio)",
              "Shakira - Nassau (Audio)",
              "Shakira - Tiempo Sin Verte (Audio)",
              "Shakira - Última (Audio)",
              "Shakira, Bizarrap - La Fuerte (Audio)"
            ]
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_video_title AS (\nSELECT\n  video_title\nFROM\n  youtube_stats.video_info\nWHERE\n  channel_id = ${channel_info__channel_id}\nORDER BY\n  video_title\n)\nSELECT\n  video_title\nFROM\n  cte_video_title\nUNION ALL\nSELECT\n 'no data' as video_title\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_title b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_title)",
          "hide": 0,
          "includeAll": false,
          "label": "Video Title",
          "multi": true,
          "name": "video_info__video_title",
          "options": [],
          "query": "WITH cte_video_title AS (\nSELECT\n  video_title\nFROM\n  youtube_stats.video_info\nWHERE\n  channel_id = ${channel_info__channel_id}\nORDER BY\n  video_title\n)\nSELECT\n  video_title\nFROM\n  cte_video_title\nUNION ALL\nSELECT\n 'no data' as video_title\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_title b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_title)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": false,
            "text": "67",
            "value": "67"
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_channel_id AS (\nSELECT\n  channel_id\nFROM\n  youtube_stats.channel_info\nWHERE\n  channel_name = '${channel_info__channel_name}'\n)\nSELECT\n  channel_id\nFROM\n  cte_channel_id\nUNION ALL\nSELECT\n 0 AS channel_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_id)",
          "hide": 2,
          "includeAll": false,
          "multi": false,
          "name": "channel_info__channel_id",
          "options": [],
          "query": "WITH cte_channel_id AS (\nSELECT\n  channel_id\nFROM\n  youtube_stats.channel_info\nWHERE\n  channel_name = '${channel_info__channel_name}'\n)\nSELECT\n  channel_id\nFROM\n  cte_channel_id\nUNION ALL\nSELECT\n 0 AS channel_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_id)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": true,
            "text": [
              "All"
            ],
            "value": [
              "$__all"
            ]
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_video_id AS (\nSELECT\n  video_id\nFROM\n  youtube_stats.video_info\nWHERE\n  video_title IN (${video_info__video_title})\n)\nSELECT\n  video_id\nFROM\n  cte_video_id\nUNION ALL\nSELECT\n 0 AS video_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_id)",
          "hide": 2,
          "includeAll": true,
          "multi": true,
          "name": "video_info__video_id",
          "options": [],
          "query": "WITH cte_video_id AS (\nSELECT\n  video_id\nFROM\n  youtube_stats.video_info\nWHERE\n  video_title IN (${video_info__video_title})\n)\nSELECT\n  video_id\nFROM\n  cte_video_id\nUNION ALL\nSELECT\n 0 AS video_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_id)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": false,
            "text": "Feid",
            "value": "Feid"
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_channel_name AS (\nSELECT\n  channel_name\nFROM\n  youtube_stats.channel_info\nWHERE\n  channel_name <> '${channel_info__channel_name}'\nORDER BY\n  channel_name ASC\n)\nSELECT\n  channel_name\nFROM\n  cte_channel_name\nUNION ALL\nSELECT\n 'no data' AS channel_name\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_name b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_name)",
          "hide": 0,
          "includeAll": false,
          "label": "Channel Name 2",
          "multi": false,
          "name": "channel_info__channel_name_2",
          "options": [],
          "query": "WITH cte_channel_name AS (\nSELECT\n  channel_name\nFROM\n  youtube_stats.channel_info\nWHERE\n  channel_name <> '${channel_info__channel_name}'\nORDER BY\n  channel_name ASC\n)\nSELECT\n  channel_name\nFROM\n  cte_channel_name\nUNION ALL\nSELECT\n 'no data' AS channel_name\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_name b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_name)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": false,
            "text": "58",
            "value": "58"
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_channel_id AS (\nSELECT\n  channel_id\nFROM\n  youtube_stats.channel_info\nWHERE\n  channel_name = '${channel_info__channel_name_2}'\n)\nSELECT\n  channel_id\nFROM\n  cte_channel_id\nUNION ALL\nSELECT\n 0 AS channel_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_id)",
          "hide": 2,
          "includeAll": false,
          "multi": false,
          "name": "channel_info__channel_id_2",
          "options": [],
          "query": "WITH cte_channel_id AS (\nSELECT\n  channel_id\nFROM\n  youtube_stats.channel_info\nWHERE\n  channel_name = '${channel_info__channel_name_2}'\n)\nSELECT\n  channel_id\nFROM\n  cte_channel_id\nUNION ALL\nSELECT\n 0 AS channel_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_id)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": true,
            "text": [
              "Feid, Yandel - Brickell (Lyric Video)",
              "Feid, Yandel - De Negro (Lyric Video)",
              "Feid, Yandel - Fecha (Lyric Video)",
              "Feid, Yandel - No Digas Nada (Lyric Video)",
              "Feid, Yandel - Pa Janguiar (Lyric Video)"
            ],
            "value": [
              "Feid, Yandel - Brickell (Lyric Video)",
              "Feid, Yandel - De Negro (Lyric Video)",
              "Feid, Yandel - Fecha (Lyric Video)",
              "Feid, Yandel - No Digas Nada (Lyric Video)",
              "Feid, Yandel - Pa Janguiar (Lyric Video)"
            ]
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_video_title AS (\nSELECT\n  video_title\nFROM\n  youtube_stats.video_info\nWHERE\n  channel_id = ${channel_info__channel_id_2}\nORDER BY\n  video_title\n)\nSELECT\n  video_title\nFROM\n  cte_video_title\nUNION ALL\nSELECT\n 'no data' as video_title\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_title b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_title)",
          "hide": 0,
          "includeAll": false,
          "label": "Video Title",
          "multi": true,
          "name": "video_info__video_title_2",
          "options": [],
          "query": "WITH cte_video_title AS (\nSELECT\n  video_title\nFROM\n  youtube_stats.video_info\nWHERE\n  channel_id = ${channel_info__channel_id_2}\nORDER BY\n  video_title\n)\nSELECT\n  video_title\nFROM\n  cte_video_title\nUNION ALL\nSELECT\n 'no data' as video_title\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_title b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_title)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": true,
            "text": [
              "All"
            ],
            "value": [
              "$__all"
            ]
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_video_id AS (\nSELECT\n  video_id\nFROM\n  youtube_stats.video_info\nWHERE\n  video_title IN (${video_info__video_title_2})\n)\nSELECT\n  video_id\nFROM\n  cte_video_id\nUNION ALL\nSELECT\n 0 AS video_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_id)",
          "hide": 2,
          "includeAll": true,
          "multi": true,
          "name": "video_info__video_id_2",
          "options": [],
          "query": "WITH cte_video_id AS (\nSELECT\n  video_id\nFROM\n  youtube_stats.video_info\nWHERE\n  video_title IN (${video_info__video_title_2})\n)\nSELECT\n  video_id\nFROM\n  cte_video_id\nUNION ALL\nSELECT\n 0 AS video_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_video_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_video_id)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        }
      ]
    },
    "time": {
      "from": "now-14d/d",
      "to": "now/d"
    },
    "timepicker": {},
    "timezone": "",
    "title": "Youtube Channel Videos",
    "uid": "Og7tP6bIk",
    "version": 40,
    "weekStart": ""
  },
  "folderUid": "",
  "overwrite": true
}
