{
  "dashboard": {
    "annotations": {
      "list": [
        {
          "builtIn": 1,
          "datasource": {
            "type": "grafana",
            "uid": "-- Grafana --"
          },
          "enable": true,
          "hide": true,
          "iconColor": "rgba(0, 211, 255, 1)",
          "name": "Annotations & Alerts",
          "type": "dashboard"
        }
      ]
    },
    "editable": true,
    "fiscalYearStartMonth": 0,
    "graphTooltip": 0,
    "links": [
      {
        "asDropdown": false,
        "icon": "external link",
        "includeVars": false,
        "keepTime": false,
        "tags": [
          "youtube"
        ],
        "targetBlank": false,
        "title": "Navigate",
        "tooltip": "",
        "type": "dashboards",
        "url": ""
      }
    ],
    "panels": [
      {
        "collapsed": false,
        "gridPos": {
          "h": 1,
          "w": 24,
          "x": 0,
          "y": 0
        },
        "id": 5,
        "panels": [],
        "title": "Error Messages",
        "type": "row"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "fieldConfig": {
          "defaults": {
            "color": {
              "fixedColor": "#ffd0d6",
              "mode": "fixed"
            },
            "custom": {
              "align": "auto",
              "cellOptions": {
                "mode": "basic",
                "type": "color-background"
              },
              "inspect": false
            },
            "mappings": [],
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": null
                },
                {
                  "color": "red",
                  "value": 80
                }
              ]
            }
          },
          "overrides": [
            {
              "matcher": {
                "id": "byName",
                "options": "Timestamp"
              },
              "properties": [
                {
                  "id": "custom.width",
                  "value": 161
                }
              ]
            },
            {
              "matcher": {
                "id": "byName",
                "options": "Process Group"
              },
              "properties": [
                {
                  "id": "custom.width",
                  "value": 220
                }
              ]
            },
            {
              "matcher": {
                "id": "byName",
                "options": "Processor"
              },
              "properties": [
                {
                  "id": "custom.width",
                  "value": 119
                }
              ]
            }
          ]
        },
        "gridPos": {
          "h": 16,
          "w": 24,
          "x": 0,
          "y": 1
        },
        "id": 2,
        "options": {
          "cellHeight": "sm",
          "footer": {
            "countRows": false,
            "fields": "",
            "reducer": [
              "sum"
            ],
            "show": false
          },
          "showHeader": true,
          "sortBy": []
        },
        "pluginVersion": "10.4.2",
        "targets": [
          {
            "datasource": {
              "type": "grafana-postgresql-datasource",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "rawQuery": true,
            "rawSql": "SELECT\n  error_timestamp AS \"Timestamp\",\n  error_process_group AS \"Process Group\",\n  error_processor AS \"Processor\",\n  error_flowfile_content AS \"Flowfile Content\",\n  error_metadata AS \"Error Metadata\"\nFROM\n  youtube_stats.error_messages\nWHERE\n  $__timeFilter(error_timestamp) AND\n  error_process_group IN ($process_group) AND\n  error_processor IN ($processor)\nORDER BY\n  error_timestamp DESC",
            "refId": "A",
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            }
          }
        ],
        "title": "Error History",
        "type": "table"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 15,
          "w": 12,
          "x": 0,
          "y": 17
        },
        "id": 3,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto"
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * CONFIGURACIÓN INICIAL\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Mapea los valores de la query en Grafana con los valores que vamos a representar en Echarts además de ajustar valores de configuración\n * globales para la gráfica.\n * \n * - tooltip_trigger: 'item' para solo mostrar información de la barra / línea concreta, 'axis' para mostrar todos los datos del eje.\n * \n * - category_axis: Lista de opciones para el eje de categorías (tiempo, días de la semana, año, etc.)\n *                  * show_splitline: true/false. Mostraro línea de separación entre barras.\n *                  * splitline_interval: Si se activa la línea de separación, cada cuantas barras queremos que aparezca (0 = cada barra,\n *                                        1 cada dos, etc.)\n *                  * axisPointer:  'line' / 'shadow' (cuando el ratón pasa por encima se mostrará una sombra o una línea) / 'cross'.\n * \n * - value_axis: Lista de opciones para el eje de valores\n *               * show_values_and_splitline: true/false. Mostrar el eje de valores. Si se activa, conlleva un escalado de la gráfica\n *                                            debido a un pequeño error en Echarts que hace que la última línea especificada por este eje\n *                                            sea el máximo con todos sus digitos. Este escalado lo que hace es redondear esta última\n *                                            línea al múltiplo de diez más próximo (con exponencial relativa a la escala que se esté\n *                                            utilizando).\n *               * scale_min: true/false. Sustituye el mínimo mostrado en la gráfica, generalmente de 0 al mínimo de los valores. Ayuda a\n *                            escalar la gráfica y poder distinguir mejor la diferencia entre valores, sobre todo para gráficas en las que\n *                            los valores sean muy elevados pero luego estos valores sean relativamente muy similares en valor.\n * \n * - time_reference:    Nombre de la columna relacionada con el timestamp / día / semana ... en el que vamos a agrupar los datos.\n * \n * - time_reference_description:    Descripción que aparecerá en la gráfica sobre el tipo de referencia de tiempo utilizada (día de \n *                                  la semana, hora, ...)\n * \n * - series_reference:    Nombre de la columna que identifica las series en las que se agrupan los datos (tantas series como \n *                        valores únicos en la columna). Habitualmente utilizado para agrupar datos por el nombre/id del dispositivo \n *                        o referencias temporales (franja horaria, día de la semana, etc..).\n * \n * - compact_series_text: true/false. Activar en caso de que el texto mostrado que define la serie sea muy largo. (otra opción sería\n *                                    cambiar el campo 'legend' si es muy largo, o el tamaño del propio texto en las variables\n *                                    textSize, text_size, font-size, fontSize que hay a lo largo del script). \n * \n * - orientation:   Orientación de la gráfica 'horizontal'/'vertical'\n * \n * - legend: Lista de opciones para configurar la leyenda.\n *           * show:  true/false. Flag para mostrar u ocultar la leyenda en el panel.\n *           * table: true/false. Mostrar leyenda como tabla con estadísticas\n *           * compact_table: Si es 'true' cuando hay más de 7 elementos en la leyenda de la Gráfica pasamos a tener dos tablas y así\n *                            evitamos que la leyenda ocupe demasiado espacio.\n * \n * - number_of_decimals:  Número de decimales a mostrar en la gráfica, leyenda, tooltip, etc.\n * \n * - number_format: Seguir el formato 'locale' en números enteros (coma cada tres cifras), 'locale_dot' (punto en vez de coma), \n *                  'short' (simplificar en K's, M's, G's, etc. el número) o null (sin formato).\n * \n * - show_zeros:  Si es 'true' en el tooltip aparecerán todos las métricas, aunque tengan valor 0. Si es 'false', esas métricas\n *                que no tienen un valor para ese instante temporal o que su valor es 0 no aparecerán en el tooltip.\n *\n * - stack: Si queremos que se apilen los datos de todos los dispositivos para esta métrica (se seguirá diferenciando por colores).\n * \n * - selectedMode:  Si queremos habilitar la opción de filtrado al hacer click en alguno de los elementos de la leyenda.\n * \n * - disable_emphasis: Flag que habilita/deshabilita el modo énfasis en la serie cuando se pasa el mouse sobre la leyenda o el dato, \n *                     se oculten el resto de datos\n * \n * - parameters:    Indicamos explícitamente las columnas que vamos a mapear desde Grafana. Las columnas ya indicadas anteriormente\n *                  en 'time_reference' y en 'series_refernece' también se deben indicar en este array pero únicamente se les rellena\n *                  el valor de 'name' y 'queryId'. Para el resto de métricas que queramos representar en la gráfica hace falta rellenar\n *                  los siguientes campos:\n * \n *                  * name: Nombre de la columna.\n *                  * queryId: Id de la query en Grafana a la que pertenece esa columna (por defecto: A, B, C...).\n *                  * legend: Información adicional que aparecerá en la gráfica al lado del nombre de dispositivo en la leyenda (por\n *                            ejemplo: 'Número de vehículos en ', 'Número de multas en ', 'Número de personas en '...)\n *                  * color: Lista de colores que va a coger la gráfica para representar la métrica de cada dispositivo. Se recomienda\n *                           poner tantos colores como dispositivos haya para que así no se repitan.\n *                  * intensity: La intensidad de color de rellena de la barra/línea (1 = intensidad máxima, 0 = transparente).\n *                  * type: 'bar' = Gráfico de barras para esta métrica, 'line' = Gráfico de líneas para esta métrica.\n *                  * scale_reduction: En caso de que las líneas/barras de la gráfica se salgan de la propia gráfica, se puede jugar con\n *                                     este valor. (scale_reduction > 1 -> reducir escala, scale_reduction < 1 -> aumentar escala).\n *                  * axisIndex: Si queremos que se rigan por la misma escala varias métricas utilizaremos el mismo índice, en caso de que\n *                               no queramos utilizar la misma escala utilizaremos distintos índices. (por ejemplo, si una métrica es el \n *                               número de vehículos multados y otra métrica es el importe total de multas, tendrá sentido utilizar\n *                               índices diferentes ya que el importe de multas normalmente tendrá valores muchísimo más grandes que el\n *                               número de vehículos).\n *                  * show_label: flag que establece si se muestra o no el label con los valores de la serie.\n * \n * - no_data_prommpt: Cuadro por defecto que se mostrará si no se tienen datos.\n * \n * - bar_type_general_settings: Configuración general para el gráfico de barras (si se utiliza en alguna métrica).\n * \n * - line_type_general_settings: Configuración general para el gráfico de líneas (si se utiliza en alguna métrica).\n * \n * - label_text_format: Formato del texto que se utiliza para representar los valores de cada métrica y dispositivo.\n * \n *   Nota 1: Si Grafana no carga bien los datos (habiendo revisado que has puesto bien los nombres para el mapeo)... es probable que no\n * tengas las opción de la gráfica puesta en 'Table' (en vez de en 'Time series').\n *   Nota 2: El campo 'series_reference' debe ser único, si no puede haber problemas a la hora de ordenar los datos en la gráfica.\n *   Nota 3: Para gráficas verticales, si no se ve el 'name' (descripción de lo que representa ese eje), modificar de manera ad-hoc los\n *           valores en nameTextStyle.padding (3 element) / boundaryGap.\n *   Nota 4: Si se quiere cambiar el nombre con el que aparece cada serie en la leyenda/tooltip, cambiar la línea de código que define\n *           series_name_to_processed_data.show_text.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'cross'\n  },\n\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: false\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'error_process_group',\n  compact_series_text: true,\n  orientation: 'vertical',\n\n  legend: {\n    show: true,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: null,\n  show_zeros: true,\n\n  stack: true,\n  selectedMode: true,\n  disable_emphasis: false,\n\n  parameters: [\n    {\n      name: 'daily_errors',\n      queryId: 'A',\n      legend: '',\n      hide_upper_index: true,\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 1,\n      intensity: '1',\n      type: 'bar',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: true\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    },\n    {\n      name: 'error_process_group',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1\n    },\n    areaStyle: {\n      opacity: .2,\n    }\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n/** \n * Inicializamos la configuración del eje X y del eje Y.\n * \n * Si la gráfica es horizontal, el eje Y se encarga de mostrar las etiquetas para el eje temporal; si es vertical es el \n * eje X el que muestra las etiquetas para el eje temporal.\n * \n * Las variables 'value_index' y 'category_index' nos van a ayudar a lo largo del script ya que los pares valor y \n * referencia_temporal que necesitamos para la representación de los datos pueden tener distinto orden dependiendo de si la \n * gráfica es vertical u horizontal:\n *  \n *  vertical -> valor: indice 0, referencia temporal: indice 1 (eje y)\n *  horizontal -> valor: indice 1, referencia temporal: indice 0 (eje x)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n    /*boundaryGap: false*/\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* Comprobamos que no hay variables mal configuradas */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * FUNCIONES AUXILIARES\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Listado de funciones auxiliares utilizadas para enriquecer y/o dar formato la visualización de datos \n * con Apache Echarts:\n *  - rgbLight: Función que a partir de un rgb de entrada nos devuelve su variante más clara (dependiendo de gradient_diff) y \n *              con una intensidad específica (intensity).\n *  - rgbDark: Función que a partir de un rgb de entrada nos devuelve su variante más oscura (dependiendo de gradient_diff) y \n *             con una intensidad específica (intensity).\n *  - numberToShortFormat: Función que convierte un valor numérico en su forma abreviada 1K, 1M, ...\n *  - numberFormat: Formateo de métricas según el valor global configurado (number_format)\n *  - addSum: En caso de que la opción stack se haya configurado a 'true' nos ayuda a calcular el total acumulado en la estructura\n *            sum_stack para todos los dispositivos en una métrica, cuyo valor final es el que saldrá al final de cada barra.\n *  - getMax: Utilizado si se quiere tener una 'splitLine' para el eje de valores y así evitar que la última línea no sea un número\n *            redondo (múltiplo de 10). Coge el valor máximo y lo redondea al próximo múltiplo de 10 (elevado a la escala que se\n *            esté utilizando).\n *  - getMin: Utilizado para obtener el valor mínimo a representar y así escalar la gráfica a este valor.\n *  - compareInterval:  Función auxiliar que compara dos intervalos de tiempo (a, b) ambos en formato HH:MM:SS, y devuelve un valor\n *                      entero de la diferencia entre ambos. Se emplea para ordenar series de tiempos.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  // lista de sufijos para formato abreviado\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  // si no se tienen que mostrar decimales y se tiene el valor 999 o menor, no se formatea\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  // calculamos el sufijo que corresponde al value\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  //dividimos entre la potencia base 1000 equivalente al suffixNum y se le aplica la precisión al resultado\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Antes de sumar el valor correspondiente a cada query, métrica y referencia temporal\n   * debemos comprobar que la clave exista (y si no existe se crea:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Métrica: sum_stack[query_index][parameter_index] = {}\n   *                                        Referencia temporal: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Ejemplo de estructura final que tendrá:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Domingo: 58,\n   *        Jueves: 69,\n   *        Lunes: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Domingo: 74,\n   *        Jueves: 78,\n   *        Lunes: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Devuelve el mayor entero que se obtiene de dividir primero por el pow de 10 elevado a length, con un Math.ceil, y después \n   * multiplicar por el pow de 10 elevado a length, aplicado al producto value.max * scale_reduction. \n   * Ejemplo:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Devuelve el máximo entre:\n   * - 0\n   * - el entero (menor o igual) que se obtiene de, dividir primero por el pow de 10 con un Math.floor, y después multiplicar por\n   *    el pow de 10, aplicado al valor min.\n   * Ejemplo:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    // Calcula el exponencial de la potencia base 10 en función del valor\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  // convertimos el intervalo HH:MM:SS-hh:mm:ss en el entero formado por HHMMSS \n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Extraemos los datos que nos vienen en Grafana de la query. Ejemplo:\n * raw_data = {\n *    fines: {\n *        day: ['Domingo', 'Sábado', 'Viernes', ...],\n *        device: ['Caracollo', 'Caracollo', 'Caracollo', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Domingo', 'Sábado', 'Viernes', ...],\n *        device: ['Caracollo', 'Caracollo', 'Caracollo', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* Si hay stacking se añade una serie 'fantasma' que se encarga de mostrar la suma total al final de cada barra: un valor 0 al final de cada\n   array de métricas, un valor por defecto al final del array de tiempos y '__sum_stack' en el array de dispositivos */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Los índices siempre deben ser incrementales, no puede existir una serie con un axisIndex: 1 si no hay otra serie con axisIndex: 0. Para controlar\n   este error, creamos un 'diccionario' que mapea los valores de los índices que hemos indicado en la configuración inicial con unos valores\n   que eviten el error */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* Si no tenemos ningún dato, lo indicamos y nos salimos del script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * Agrupamos las métricas por dispositivo y mapeamos cada valor con su referencia temporal. Ejemplo:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Caracollo: [[22, 'Domingo'], [22, 'Sábado'], [28, 'Viernes'], ...],\n *            Ocotavi: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Caracollo: [[23, 'Domingo'], [25, 'Sábado'], [24, 'Viernes], ...],\n *            Ocotavi: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Inicializamos las variables con las que vamos a representar los datos, siguiendo la configuración inicial definida.\n * \n * - seriesData: Array donde vamos a ir insertando la configuración para cada métrica/dispositivo.\n * \n * - legendTable: Leyenda/tabla que se muestra abajo de la gráfica para indicar el nombre de la métrica + dispositivo y\n *                datos estadísticos.\n * \n * - series_name_to_processed_data: Traductor que nos servirá en las funciones formatter para obtener los índices y acceder\n *                                  a los distintos elementos de nuestros arrays con datos (processed_data, raw_data, etc.)\n *                                  a partir de un seriesName.\n * \n * - sum_stack_finished: Trigger de reseteo. Detecta cualquier acción del usuario (como el hacer click en la leyenda\n *                       para activar el filtrado) para resetear el sumatorio y así volver a sumar todas las barras/líneas\n *                       visibles.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* Recorremos processed_data por query. Nota: Object.entries es una manera para evitar acceder a referencias en lugar de \n   valores primitivos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' nos permitirá por cada query recorrer los datos por dispositivo (se discrimina por query ya que puede\n    darse el caso que un dispositivo tenga datos para los resultados de una query pero para otra query no tenga ningún dato, así\n    somos más selectivos).*/\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* Obtenemos la configuración indicada al inicio del script para esta métrica. Nota: Con Object.assign conseguimos una copia\n       superficial de la configuración, así evitamos trabajar con referencias en un bucle, la inicialización 'let' también\n       ayuda a solventar este problema. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* Añadimos un nuevo elemento al eje de los datos aplicando la reducción de escala si le corresponde\n     * El 1 que añadimos en scale_reduction es para evitar que en gráficas en las que los valores representados son valores pequeños\n     * (1, 2, etc.), el factor 'scale_reduction' no influye mucho y es muy probable que se siga sin ver la etiqueta ya que la barra\n     * es muy larga.\n     */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          // No queremos que aparezca en el eje de valores, ya que ya aparece el 'legend_name' en la propia leyenda.\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          // No queremos que aparezca en el eje de valores, ya que ya aparece el 'legend_name' en la propia leyenda.\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* Recorremos la métrica por dispositivo */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* Creamos la configuración para esta métrica y dispositivo */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Objeto que nos servirá en las funciones formatter para obtener los índices y acceder a los distintos elementos\n         de processed_data y raw_data a partir de un seriesName */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Dependiendo de si está configurado como gráfico tipo línea o gráfico de barras aplicamos unos cambios u otros\n         'series_aux' será la serie que se insertará al array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* Definimos el alias, asignamos los datos procesados y el índice a la serie */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* Para esta métrica y dispositivo calculamos la media, el mínimo y el máximo teniendo en cuenta los valores en\n         todas las referencias temporales */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* Después de hacer los cálculos preparamos el texto para mostrar en la tabla de la leyenda. Nota: Si el nombre del dispositivo\n         es muy grande se recorta texto para que no haya superposición de texto. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* Se añade la serie al array. Para evitar añadir ninguna referencia al array de series se utiliza este 'truco' del JSON.stringify */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* Como el JSON.stringify no permite copiar funciones, y vamos a necesitar funciones para configurar cómo queremos mostrar los valores\n         de las métricas dependiendo de si se hace apilamiento/stacking o no, modificamos la serie después de haberla insertado en el array */\n      if (global_conf.stack) {\n        /* Para identificar cada stacking/agrupación, le asignamos el nombre de la query y el nombre de la métrica */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* Si hay stacking se representa el valor total acumulado (almacenado en sum_stack) en el último elemento de la barra/línea,\n           en el resto de líneas/barras no se representa ningún valor */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /**\n               * Se resetea el conteo para volver a hacer el sumatorio en el stack.\n              */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* Si no hay stacking, se representa el valor en cada barra / línea y no hace falta calcular nada para sum_stack */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Dependiendo de si la gráfica es vertical/horizontal queda mejor colocar el valor a la derecha o arriba de cada barra / línea */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Acciones programadas que se activan cuando un evento determinado se activa.\n *  - legendselectchanged:  Cuando se pulsa un elemento en la leyenda con objetivo de filtrar por serie. La acción es resetear\n *                          todos los conteos a 0 si el stacking está activado (para que vuelva a calcularse el sumatorio).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    console.log(context);\n    /* Truco para actualizar la gráfica entera y forzar a que se vuelva a calcular el sumatorio */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * DISEÑO DE LEYENDA CON ESTADÍSTICAS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Inicializamos los valores que vamos a utilizar para colocar y representar la leyenda.\n * \n * - bottom_grid: Posición donde comienza la gráfica de barras / líneas.\n * - bottom_legend_head: Posición donde se sitúa el título de la leyenda (nombre de dispositivo, max, min, mean...)\n * - config_legend_head: Configuración del texto del título de la leyenda.\n * - config_legend_table: Listado de métricas/dispositivos con sus estadísticas.\n * - series_name_list_splitted:   Utilizado en caso de que en la configuración inicial 'compact_legend' sea true y haya más de 7\n *                                elementos en la tabla. \n * - legend_alignment: configuración para el alineamiento de la tabla.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Configuración ad-hoc para ajustar la leyenda y la gráfica según el número de elementos que haya y así evitar overlap de leyenda\n    y gráfica. Serán diferentes dependiendo de si la gráfica es vertical/horizontal o de si 'compact_legend' sea true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   Lista de 'seriesName' de las series creadas anteriormente (sin la serie 'fantasma'\n                                      __sum_stack que únicamente sirve para arreglar el sumatorio en caso de stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* En caso de que 'compact_legend' sea true y haya más de 7 elementos, se dividirá la leyenda en dos tablas a cada lado */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* 'textHeight' será utilizado para calcular el tamaño de la tabla dependiendo del número de elementos que tenga la misma. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Bucle necesario para mostrar dos tablas en caso de que 'compact_legend' sea true y haya más de 7 elementos. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Configuración ad-hoc para determinar el fin de la tabla y el inicio del título de la tabla */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 2) * series_name_list_aux.length;\n    } else if (series_name_list_without_sum.length <= 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 3.75) * series_name_list_aux.length;\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 3) * series_name_list_aux.length;\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* Evitamos duplicados, solo mostramos una leyenda que va a englobar a todos los dispositivos */\n      data: [series_name_list_aux[0]],\n      /* Que al hacer click no haga nada */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* Si hay dos tablas, colocar una a la izquierda y otra a la derecha, si no, colocar la tabla en el centro */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        // Gracias al array legendTable mapeamos el nombre del dato con el texto.\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* Que al hacer click no haga nada */\n      selectedMode: global_conf.selectedMode\n    };\n    /* Si hay dos tablas, colocar una a la izquierda y otra a la derecha, si no, colocar la tabla en el centro */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Configuración ad-hoc para determinar el fin de la tabla y el inicio de la gráfica */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    // Try 'horizontal'\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DISEÑO PANEL ECHARTS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Retornamos los elementos de visualización de datos para que se muestren en el panel de Grafana \n * (título del panel, grid del panel, eje X, eje Y, series de datos, leyenda, tooltip, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "grafana-postgresql-datasource",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "rawQuery": true,
            "rawSql": "WITH cte_raw_data AS (\nSELECT\n  error_process_group,\n  error_timestamp,\n  1 as intensity\nFROM\n  youtube_stats.error_messages\nWHERE\n  $__timeFilter(error_timestamp) AND\n  error_process_group IN ($process_group) AND\n  error_processor IN ($processor)\n), cte_data_with_default_values AS (\nSELECT\n  *\nFROM\n  cte_raw_data\nUNION ALL\nSELECT\n  d.error_process_group,\n  gs,\n  0 AS intensity -- For the data to be sorted we need all videos to have a value in all months (even if it is 0).\nFROM\n  (SELECT DISTINCT error_process_group FROM cte_raw_data) d,\n  generate_series(DATE($__timeFrom()::timestamp with time zone), DATE($__timeTo()::timestamp with time zone), INTERVAL '1 day') gs\n), cte_result AS (\nSELECT \n  TO_CHAR(error_timestamp, 'yyyy-mm-dd') AS day,\n  error_process_group,\n  SUM(intensity) AS daily_errors\nFROM\n  cte_data_with_default_values\nGROUP BY\n  day, error_process_group\nORDER BY\n  day ASC,\n  error_process_group ASC\n)\nSELECT\n  day,\n  error_process_group,\n  daily_errors\nFROM\n  cte_result\nUNION ALL\nSELECT\n '2000-01-01' AS day,\n 'no data' AS error_process_group,\n 0 AS daily_errors\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            }
          }
        ],
        "title": "Daily Errors by Process Group",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 15,
          "w": 12,
          "x": 12,
          "y": 17
        },
        "id": 4,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto"
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * CONFIGURACIÓN INICIAL\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Mapea los valores de la query en Grafana con los valores que vamos a representar en Echarts además de ajustar valores de configuración\n * globales para la gráfica.\n * \n * - tooltip_trigger: 'item' para solo mostrar información de la barra / línea concreta, 'axis' para mostrar todos los datos del eje.\n * \n * - category_axis: Lista de opciones para el eje de categorías (tiempo, días de la semana, año, etc.)\n *                  * show_splitline: true/false. Mostraro línea de separación entre barras.\n *                  * splitline_interval: Si se activa la línea de separación, cada cuantas barras queremos que aparezca (0 = cada barra,\n *                                        1 cada dos, etc.)\n *                  * axisPointer:  'line' / 'shadow' (cuando el ratón pasa por encima se mostrará una sombra o una línea) / 'cross'.\n * \n * - value_axis: Lista de opciones para el eje de valores\n *               * show_values_and_splitline: true/false. Mostrar el eje de valores. Si se activa, conlleva un escalado de la gráfica\n *                                            debido a un pequeño error en Echarts que hace que la última línea especificada por este eje\n *                                            sea el máximo con todos sus digitos. Este escalado lo que hace es redondear esta última\n *                                            línea al múltiplo de diez más próximo (con exponencial relativa a la escala que se esté\n *                                            utilizando).\n *               * scale_min: true/false. Sustituye el mínimo mostrado en la gráfica, generalmente de 0 al mínimo de los valores. Ayuda a\n *                            escalar la gráfica y poder distinguir mejor la diferencia entre valores, sobre todo para gráficas en las que\n *                            los valores sean muy elevados pero luego estos valores sean relativamente muy similares en valor.\n * \n * - time_reference:    Nombre de la columna relacionada con el timestamp / día / semana ... en el que vamos a agrupar los datos.\n * \n * - time_reference_description:    Descripción que aparecerá en la gráfica sobre el tipo de referencia de tiempo utilizada (día de \n *                                  la semana, hora, ...)\n * \n * - series_reference:    Nombre de la columna que identifica las series en las que se agrupan los datos (tantas series como \n *                        valores únicos en la columna). Habitualmente utilizado para agrupar datos por el nombre/id del dispositivo \n *                        o referencias temporales (franja horaria, día de la semana, etc..).\n * \n * - compact_series_text: true/false. Activar en caso de que el texto mostrado que define la serie sea muy largo. (otra opción sería\n *                                    cambiar el campo 'legend' si es muy largo, o el tamaño del propio texto en las variables\n *                                    textSize, text_size, font-size, fontSize que hay a lo largo del script). \n * \n * - orientation:   Orientación de la gráfica 'horizontal'/'vertical'\n * \n * - legend: Lista de opciones para configurar la leyenda.\n *           * show:  true/false. Flag para mostrar u ocultar la leyenda en el panel.\n *           * table: true/false. Mostrar leyenda como tabla con estadísticas\n *           * compact_table: Si es 'true' cuando hay más de 7 elementos en la leyenda de la Gráfica pasamos a tener dos tablas y así\n *                            evitamos que la leyenda ocupe demasiado espacio.\n * \n * - number_of_decimals:  Número de decimales a mostrar en la gráfica, leyenda, tooltip, etc.\n * \n * - number_format: Seguir el formato 'locale' en números enteros (coma cada tres cifras), 'locale_dot' (punto en vez de coma), \n *                  'short' (simplificar en K's, M's, G's, etc. el número) o null (sin formato).\n * \n * - show_zeros:  Si es 'true' en el tooltip aparecerán todos las métricas, aunque tengan valor 0. Si es 'false', esas métricas\n *                que no tienen un valor para ese instante temporal o que su valor es 0 no aparecerán en el tooltip.\n *\n * - stack: Si queremos que se apilen los datos de todos los dispositivos para esta métrica (se seguirá diferenciando por colores).\n * \n * - selectedMode:  Si queremos habilitar la opción de filtrado al hacer click en alguno de los elementos de la leyenda.\n * \n * - disable_emphasis: Flag que habilita/deshabilita el modo énfasis en la serie cuando se pasa el mouse sobre la leyenda o el dato, \n *                     se oculten el resto de datos\n * \n * - parameters:    Indicamos explícitamente las columnas que vamos a mapear desde Grafana. Las columnas ya indicadas anteriormente\n *                  en 'time_reference' y en 'series_refernece' también se deben indicar en este array pero únicamente se les rellena\n *                  el valor de 'name' y 'queryId'. Para el resto de métricas que queramos representar en la gráfica hace falta rellenar\n *                  los siguientes campos:\n * \n *                  * name: Nombre de la columna.\n *                  * queryId: Id de la query en Grafana a la que pertenece esa columna (por defecto: A, B, C...).\n *                  * legend: Información adicional que aparecerá en la gráfica al lado del nombre de dispositivo en la leyenda (por\n *                            ejemplo: 'Número de vehículos en ', 'Número de multas en ', 'Número de personas en '...)\n *                  * color: Lista de colores que va a coger la gráfica para representar la métrica de cada dispositivo. Se recomienda\n *                           poner tantos colores como dispositivos haya para que así no se repitan.\n *                  * intensity: La intensidad de color de rellena de la barra/línea (1 = intensidad máxima, 0 = transparente).\n *                  * type: 'bar' = Gráfico de barras para esta métrica, 'line' = Gráfico de líneas para esta métrica.\n *                  * scale_reduction: En caso de que las líneas/barras de la gráfica se salgan de la propia gráfica, se puede jugar con\n *                                     este valor. (scale_reduction > 1 -> reducir escala, scale_reduction < 1 -> aumentar escala).\n *                  * axisIndex: Si queremos que se rigan por la misma escala varias métricas utilizaremos el mismo índice, en caso de que\n *                               no queramos utilizar la misma escala utilizaremos distintos índices. (por ejemplo, si una métrica es el \n *                               número de vehículos multados y otra métrica es el importe total de multas, tendrá sentido utilizar\n *                               índices diferentes ya que el importe de multas normalmente tendrá valores muchísimo más grandes que el\n *                               número de vehículos).\n *                  * show_label: flag que establece si se muestra o no el label con los valores de la serie.\n * \n * - no_data_prommpt: Cuadro por defecto que se mostrará si no se tienen datos.\n * \n * - bar_type_general_settings: Configuración general para el gráfico de barras (si se utiliza en alguna métrica).\n * \n * - line_type_general_settings: Configuración general para el gráfico de líneas (si se utiliza en alguna métrica).\n * \n * - label_text_format: Formato del texto que se utiliza para representar los valores de cada métrica y dispositivo.\n * \n *   Nota 1: Si Grafana no carga bien los datos (habiendo revisado que has puesto bien los nombres para el mapeo)... es probable que no\n * tengas las opción de la gráfica puesta en 'Table' (en vez de en 'Time series').\n *   Nota 2: El campo 'series_reference' debe ser único, si no puede haber problemas a la hora de ordenar los datos en la gráfica.\n *   Nota 3: Para gráficas verticales, si no se ve el 'name' (descripción de lo que representa ese eje), modificar de manera ad-hoc los\n *           valores en nameTextStyle.padding (3 element) / boundaryGap.\n *   Nota 4: Si se quiere cambiar el nombre con el que aparece cada serie en la leyenda/tooltip, cambiar la línea de código que define\n *           series_name_to_processed_data.show_text.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0,\n    axisPointer: 'cross'\n  },\n\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: false\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'error_processor',\n  compact_series_text: true,\n  orientation: 'vertical',\n\n  legend: {\n    show: true,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: null,\n  show_zeros: true,\n\n  stack: true,\n  selectedMode: true,\n  disable_emphasis: false,\n\n  parameters: [\n    {\n      name: 'daily_errors',\n      queryId: 'A',\n      legend: '',\n      hide_upper_index: true,\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 1,\n      intensity: '1',\n      type: 'bar',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: true\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    },\n    {\n      name: 'error_processor',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1\n    },\n    areaStyle: {\n      opacity: .2,\n    }\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n/** \n * Inicializamos la configuración del eje X y del eje Y.\n * \n * Si la gráfica es horizontal, el eje Y se encarga de mostrar las etiquetas para el eje temporal; si es vertical es el \n * eje X el que muestra las etiquetas para el eje temporal.\n * \n * Las variables 'value_index' y 'category_index' nos van a ayudar a lo largo del script ya que los pares valor y \n * referencia_temporal que necesitamos para la representación de los datos pueden tener distinto orden dependiendo de si la \n * gráfica es vertical u horizontal:\n *  \n *  vertical -> valor: indice 0, referencia temporal: indice 1 (eje y)\n *  horizontal -> valor: indice 1, referencia temporal: indice 0 (eje x)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n    /*boundaryGap: false*/\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* Comprobamos que no hay variables mal configuradas */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * FUNCIONES AUXILIARES\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Listado de funciones auxiliares utilizadas para enriquecer y/o dar formato la visualización de datos \n * con Apache Echarts:\n *  - rgbLight: Función que a partir de un rgb de entrada nos devuelve su variante más clara (dependiendo de gradient_diff) y \n *              con una intensidad específica (intensity).\n *  - rgbDark: Función que a partir de un rgb de entrada nos devuelve su variante más oscura (dependiendo de gradient_diff) y \n *             con una intensidad específica (intensity).\n *  - numberToShortFormat: Función que convierte un valor numérico en su forma abreviada 1K, 1M, ...\n *  - numberFormat: Formateo de métricas según el valor global configurado (number_format)\n *  - addSum: En caso de que la opción stack se haya configurado a 'true' nos ayuda a calcular el total acumulado en la estructura\n *            sum_stack para todos los dispositivos en una métrica, cuyo valor final es el que saldrá al final de cada barra.\n *  - getMax: Utilizado si se quiere tener una 'splitLine' para el eje de valores y así evitar que la última línea no sea un número\n *            redondo (múltiplo de 10). Coge el valor máximo y lo redondea al próximo múltiplo de 10 (elevado a la escala que se\n *            esté utilizando).\n *  - getMin: Utilizado para obtener el valor mínimo a representar y así escalar la gráfica a este valor.\n *  - compareInterval:  Función auxiliar que compara dos intervalos de tiempo (a, b) ambos en formato HH:MM:SS, y devuelve un valor\n *                      entero de la diferencia entre ambos. Se emplea para ordenar series de tiempos.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  // lista de sufijos para formato abreviado\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  // si no se tienen que mostrar decimales y se tiene el valor 999 o menor, no se formatea\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  // calculamos el sufijo que corresponde al value\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  //dividimos entre la potencia base 1000 equivalente al suffixNum y se le aplica la precisión al resultado\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Antes de sumar el valor correspondiente a cada query, métrica y referencia temporal\n   * debemos comprobar que la clave exista (y si no existe se crea:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Métrica: sum_stack[query_index][parameter_index] = {}\n   *                                        Referencia temporal: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Ejemplo de estructura final que tendrá:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Domingo: 58,\n   *        Jueves: 69,\n   *        Lunes: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Domingo: 74,\n   *        Jueves: 78,\n   *        Lunes: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Devuelve el mayor entero que se obtiene de dividir primero por el pow de 10 elevado a length, con un Math.ceil, y después \n   * multiplicar por el pow de 10 elevado a length, aplicado al producto value.max * scale_reduction. \n   * Ejemplo:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Devuelve el máximo entre:\n   * - 0\n   * - el entero (menor o igual) que se obtiene de, dividir primero por el pow de 10 con un Math.floor, y después multiplicar por\n   *    el pow de 10, aplicado al valor min.\n   * Ejemplo:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    // Calcula el exponencial de la potencia base 10 en función del valor\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  // convertimos el intervalo HH:MM:SS-hh:mm:ss en el entero formado por HHMMSS \n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Extraemos los datos que nos vienen en Grafana de la query. Ejemplo:\n * raw_data = {\n *    fines: {\n *        day: ['Domingo', 'Sábado', 'Viernes', ...],\n *        device: ['Caracollo', 'Caracollo', 'Caracollo', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Domingo', 'Sábado', 'Viernes', ...],\n *        device: ['Caracollo', 'Caracollo', 'Caracollo', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* Si hay stacking se añade una serie 'fantasma' que se encarga de mostrar la suma total al final de cada barra: un valor 0 al final de cada\n   array de métricas, un valor por defecto al final del array de tiempos y '__sum_stack' en el array de dispositivos */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Los índices siempre deben ser incrementales, no puede existir una serie con un axisIndex: 1 si no hay otra serie con axisIndex: 0. Para controlar\n   este error, creamos un 'diccionario' que mapea los valores de los índices que hemos indicado en la configuración inicial con unos valores\n   que eviten el error */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* Si no tenemos ningún dato, lo indicamos y nos salimos del script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * Agrupamos las métricas por dispositivo y mapeamos cada valor con su referencia temporal. Ejemplo:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Caracollo: [[22, 'Domingo'], [22, 'Sábado'], [28, 'Viernes'], ...],\n *            Ocotavi: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Caracollo: [[23, 'Domingo'], [25, 'Sábado'], [24, 'Viernes], ...],\n *            Ocotavi: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Inicializamos las variables con las que vamos a representar los datos, siguiendo la configuración inicial definida.\n * \n * - seriesData: Array donde vamos a ir insertando la configuración para cada métrica/dispositivo.\n * \n * - legendTable: Leyenda/tabla que se muestra abajo de la gráfica para indicar el nombre de la métrica + dispositivo y\n *                datos estadísticos.\n * \n * - series_name_to_processed_data: Traductor que nos servirá en las funciones formatter para obtener los índices y acceder\n *                                  a los distintos elementos de nuestros arrays con datos (processed_data, raw_data, etc.)\n *                                  a partir de un seriesName.\n * \n * - sum_stack_finished: Trigger de reseteo. Detecta cualquier acción del usuario (como el hacer click en la leyenda\n *                       para activar el filtrado) para resetear el sumatorio y así volver a sumar todas las barras/líneas\n *                       visibles.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* Recorremos processed_data por query. Nota: Object.entries es una manera para evitar acceder a referencias en lugar de \n   valores primitivos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' nos permitirá por cada query recorrer los datos por dispositivo (se discrimina por query ya que puede\n    darse el caso que un dispositivo tenga datos para los resultados de una query pero para otra query no tenga ningún dato, así\n    somos más selectivos).*/\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* Obtenemos la configuración indicada al inicio del script para esta métrica. Nota: Con Object.assign conseguimos una copia\n       superficial de la configuración, así evitamos trabajar con referencias en un bucle, la inicialización 'let' también\n       ayuda a solventar este problema. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* Añadimos un nuevo elemento al eje de los datos aplicando la reducción de escala si le corresponde\n     * El 1 que añadimos en scale_reduction es para evitar que en gráficas en las que los valores representados son valores pequeños\n     * (1, 2, etc.), el factor 'scale_reduction' no influye mucho y es muy probable que se siga sin ver la etiqueta ya que la barra\n     * es muy larga.\n     */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          // No queremos que aparezca en el eje de valores, ya que ya aparece el 'legend_name' en la propia leyenda.\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          // No queremos que aparezca en el eje de valores, ya que ya aparece el 'legend_name' en la propia leyenda.\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* Recorremos la métrica por dispositivo */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* Creamos la configuración para esta métrica y dispositivo */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Objeto que nos servirá en las funciones formatter para obtener los índices y acceder a los distintos elementos\n         de processed_data y raw_data a partir de un seriesName */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Dependiendo de si está configurado como gráfico tipo línea o gráfico de barras aplicamos unos cambios u otros\n         'series_aux' será la serie que se insertará al array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* Definimos el alias, asignamos los datos procesados y el índice a la serie */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* Para esta métrica y dispositivo calculamos la media, el mínimo y el máximo teniendo en cuenta los valores en\n         todas las referencias temporales */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* Después de hacer los cálculos preparamos el texto para mostrar en la tabla de la leyenda. Nota: Si el nombre del dispositivo\n         es muy grande se recorta texto para que no haya superposición de texto. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* Se añade la serie al array. Para evitar añadir ninguna referencia al array de series se utiliza este 'truco' del JSON.stringify */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* Como el JSON.stringify no permite copiar funciones, y vamos a necesitar funciones para configurar cómo queremos mostrar los valores\n         de las métricas dependiendo de si se hace apilamiento/stacking o no, modificamos la serie después de haberla insertado en el array */\n      if (global_conf.stack) {\n        /* Para identificar cada stacking/agrupación, le asignamos el nombre de la query y el nombre de la métrica */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* Si hay stacking se representa el valor total acumulado (almacenado en sum_stack) en el último elemento de la barra/línea,\n           en el resto de líneas/barras no se representa ningún valor */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /**\n               * Se resetea el conteo para volver a hacer el sumatorio en el stack.\n              */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* Si no hay stacking, se representa el valor en cada barra / línea y no hace falta calcular nada para sum_stack */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Dependiendo de si la gráfica es vertical/horizontal queda mejor colocar el valor a la derecha o arriba de cada barra / línea */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Acciones programadas que se activan cuando un evento determinado se activa.\n *  - legendselectchanged:  Cuando se pulsa un elemento en la leyenda con objetivo de filtrar por serie. La acción es resetear\n *                          todos los conteos a 0 si el stacking está activado (para que vuelva a calcularse el sumatorio).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    console.log(context);\n    /* Truco para actualizar la gráfica entera y forzar a que se vuelva a calcular el sumatorio */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * DISEÑO DE LEYENDA CON ESTADÍSTICAS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Inicializamos los valores que vamos a utilizar para colocar y representar la leyenda.\n * \n * - bottom_grid: Posición donde comienza la gráfica de barras / líneas.\n * - bottom_legend_head: Posición donde se sitúa el título de la leyenda (nombre de dispositivo, max, min, mean...)\n * - config_legend_head: Configuración del texto del título de la leyenda.\n * - config_legend_table: Listado de métricas/dispositivos con sus estadísticas.\n * - series_name_list_splitted:   Utilizado en caso de que en la configuración inicial 'compact_legend' sea true y haya más de 7\n *                                elementos en la tabla. \n * - legend_alignment: configuración para el alineamiento de la tabla.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Configuración ad-hoc para ajustar la leyenda y la gráfica según el número de elementos que haya y así evitar overlap de leyenda\n    y gráfica. Serán diferentes dependiendo de si la gráfica es vertical/horizontal o de si 'compact_legend' sea true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   Lista de 'seriesName' de las series creadas anteriormente (sin la serie 'fantasma'\n                                      __sum_stack que únicamente sirve para arreglar el sumatorio en caso de stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* En caso de que 'compact_legend' sea true y haya más de 7 elementos, se dividirá la leyenda en dos tablas a cada lado */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* 'textHeight' será utilizado para calcular el tamaño de la tabla dependiendo del número de elementos que tenga la misma. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Bucle necesario para mostrar dos tablas en caso de que 'compact_legend' sea true y haya más de 7 elementos. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Configuración ad-hoc para determinar el fin de la tabla y el inicio del título de la tabla */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 2) * series_name_list_aux.length;\n    } else if (series_name_list_without_sum.length <= 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 3.75) * series_name_list_aux.length;\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 3) * series_name_list_aux.length;\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* Evitamos duplicados, solo mostramos una leyenda que va a englobar a todos los dispositivos */\n      data: [series_name_list_aux[0]],\n      /* Que al hacer click no haga nada */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* Si hay dos tablas, colocar una a la izquierda y otra a la derecha, si no, colocar la tabla en el centro */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        // Gracias al array legendTable mapeamos el nombre del dato con el texto.\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* Que al hacer click no haga nada */\n      selectedMode: global_conf.selectedMode\n    };\n    /* Si hay dos tablas, colocar una a la izquierda y otra a la derecha, si no, colocar la tabla en el centro */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Configuración ad-hoc para determinar el fin de la tabla y el inicio de la gráfica */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    // Try 'horizontal'\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DISEÑO PANEL ECHARTS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Retornamos los elementos de visualización de datos para que se muestren en el panel de Grafana \n * (título del panel, grid del panel, eje X, eje Y, series de datos, leyenda, tooltip, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "grafana-postgresql-datasource",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "rawQuery": true,
            "rawSql": "WITH cte_raw_data AS (\nSELECT\n  error_processor,\n  error_timestamp,\n  1 as intensity\nFROM\n  youtube_stats.error_messages\nWHERE\n  $__timeFilter(error_timestamp) AND\n  error_process_group IN ($process_group) AND\n  error_processor IN ($processor)\n), cte_data_with_default_values AS (\nSELECT\n  *\nFROM\n  cte_raw_data\nUNION ALL\nSELECT\n  d.error_processor,\n  gs,\n  0 AS intensity -- For the data to be sorted we need all videos to have a value in all months (even if it is 0).\nFROM\n  (SELECT DISTINCT error_processor FROM cte_raw_data) d,\n  generate_series(DATE($__timeFrom()::timestamp with time zone), DATE($__timeTo()::timestamp with time zone), INTERVAL '1 day') gs\n), cte_result AS (\nSELECT \n  TO_CHAR(error_timestamp, 'yyyy-mm-dd') AS day,\n  error_processor,\n  SUM(intensity) AS daily_errors\nFROM\n  cte_data_with_default_values\nGROUP BY\n  day, error_processor\nORDER BY\n  day ASC,\n  error_processor ASC\n)\nSELECT\n  day,\n  error_processor,\n  daily_errors\nFROM\n  cte_result\nUNION ALL\nSELECT\n '2000-01-01' AS day,\n 'no data' AS error_processor,\n 0 AS daily_errors\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            }
          }
        ],
        "title": "Daily Errors by Processor",
        "type": "volkovlabs-echarts-panel"
      },
      {
        "collapsed": false,
        "gridPos": {
          "h": 1,
          "w": 24,
          "x": 0,
          "y": 32
        },
        "id": 6,
        "panels": [],
        "title": "Api Keys",
        "type": "row"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "fieldConfig": {
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "custom": {
              "align": "auto",
              "cellOptions": {
                "type": "auto"
              },
              "inspect": false
            },
            "mappings": [],
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": null
                },
                {
                  "color": "red",
                  "value": 80
                }
              ]
            }
          },
          "overrides": [
            {
              "matcher": {
                "id": "byName",
                "options": "Api Key"
              },
              "properties": [
                {
                  "id": "custom.width",
                  "value": 295
                }
              ]
            }
          ]
        },
        "gridPos": {
          "h": 3,
          "w": 24,
          "x": 0,
          "y": 33
        },
        "id": 12,
        "options": {
          "cellHeight": "sm",
          "footer": {
            "countRows": false,
            "fields": "",
            "reducer": [
              "sum"
            ],
            "show": false
          },
          "showHeader": true,
          "sortBy": []
        },
        "pluginVersion": "10.4.2",
        "repeat": "api_keys",
        "repeatDirection": "h",
        "targets": [
          {
            "datasource": {
              "type": "grafana-postgresql-datasource",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "rawQuery": true,
            "rawSql": "SELECT\n  api_key AS \"Api Key\",\n  api_key_restart_date AS \"Latest Restart Date\"\nFROM\n  youtube_stats.api_key_quota\nWHERE\n  api_key_id = $api_keys",
            "refId": "A",
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            }
          }
        ],
        "transparent": true,
        "type": "table"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "fieldConfig": {
          "defaults": {
            "color": {
              "mode": "thresholds"
            },
            "fieldMinMax": false,
            "mappings": [],
            "max": 10000,
            "min": 0,
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": null
                },
                {
                  "color": "#EAB839",
                  "value": 2000
                },
                {
                  "color": "red",
                  "value": 8000
                }
              ]
            },
            "unit": "none"
          },
          "overrides": []
        },
        "gridPos": {
          "h": 10,
          "w": 24,
          "x": 0,
          "y": 36
        },
        "id": 7,
        "options": {
          "minVizHeight": 75,
          "minVizWidth": 75,
          "orientation": "auto",
          "reduceOptions": {
            "calcs": [
              "lastNotNull"
            ],
            "fields": "",
            "values": false
          },
          "showThresholdLabels": true,
          "showThresholdMarkers": true,
          "sizing": "auto",
          "text": {}
        },
        "pluginVersion": "10.4.2",
        "repeat": "api_keys",
        "repeatDirection": "h",
        "targets": [
          {
            "datasource": {
              "type": "grafana-postgresql-datasource",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "rawQuery": true,
            "rawSql": "SELECT\n  api_key_quota\nFROM\n  youtube_stats.api_key_quota\nWHERE\n  api_key_id = $api_keys",
            "refId": "A",
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            }
          }
        ],
        "title": "Api Key Quota",
        "transparent": true,
        "type": "gauge"
      }
    ],
    "schemaVersion": 39,
    "tags": [
      "youtube",
      "error"
    ],
    "templating": {
      "list": [
        {
          "current": {
            "selected": false,
            "text": [
              "All"
            ],
            "value": [
              "$__all"
            ]
          },
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_error_process_group AS (\nSELECT DISTINCT\n  error_process_group\nFROM\n  youtube_stats.error_messages\nORDER BY\n  error_process_group\n)\nSELECT\n  error_process_group\nFROM\n  cte_error_process_group\nUNION ALL\nSELECT\n 'no data' AS error_process_group\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_error_process_group b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_error_process_group)",
          "hide": 0,
          "includeAll": true,
          "label": "Process Group",
          "multi": true,
          "name": "process_group",
          "options": [],
          "query": "WITH cte_error_process_group AS (\nSELECT DISTINCT\n  error_process_group\nFROM\n  youtube_stats.error_messages\nORDER BY\n  error_process_group\n)\nSELECT\n  error_process_group\nFROM\n  cte_error_process_group\nUNION ALL\nSELECT\n 'no data' AS error_process_group\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_error_process_group b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_error_process_group)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": false,
            "text": [
              "All"
            ],
            "value": [
              "$__all"
            ]
          },
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_error_processor AS (\nSELECT DISTINCT\n  error_processor\nFROM\n  youtube_stats.error_messages\nORDER BY\n  error_processor\n)\nSELECT\n  error_processor\nFROM\n  cte_error_processor\nUNION ALL\nSELECT\n 'no data' AS error_processor\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_error_processor b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_error_processor)",
          "hide": 0,
          "includeAll": true,
          "label": "Processor",
          "multi": true,
          "name": "processor",
          "options": [],
          "query": "WITH cte_error_processor AS (\nSELECT DISTINCT\n  error_processor\nFROM\n  youtube_stats.error_messages\nORDER BY\n  error_processor\n)\nSELECT\n  error_processor\nFROM\n  cte_error_processor\nUNION ALL\nSELECT\n 'no data' AS error_processor\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_error_processor b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_error_processor)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        },
        {
          "current": {
            "selected": false,
            "text": [
              "All"
            ],
            "value": [
              "$__all"
            ]
          },
          "datasource": {
            "type": "grafana-postgresql-datasource",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_api_key_id AS (\nSELECT\n  api_key_id\nFROM\n  youtube_stats.api_key_quota\nORDER BY\n  api_key_id\n)\nSELECT\n  api_key_id\nFROM\n  cte_api_key_id\nUNION ALL\nSELECT\n 0 AS api_key_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_api_key_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_api_key_id)",
          "hide": 2,
          "includeAll": true,
          "multi": true,
          "name": "api_keys",
          "options": [],
          "query": "WITH cte_api_key_id AS (\nSELECT\n  api_key_id\nFROM\n  youtube_stats.api_key_quota\nORDER BY\n  api_key_id\n)\nSELECT\n  api_key_id\nFROM\n  cte_api_key_id\nUNION ALL\nSELECT\n 0 AS api_key_id\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_api_key_id b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_api_key_id)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        }
      ]
    },
    "time": {
      "from": "now-14d/d",
      "to": "now/d"
    },
    "timepicker": {},
    "timezone": "browser",
    "title": "Error Messages & Api Key Quota",
    "uid": "bdjpda1anad4wc",
    "version": 34,
    "weekStart": ""
  },
  "folderUid": "",
  "overwrite": true
}
