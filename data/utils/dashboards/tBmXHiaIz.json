{
  "dashboard": {
    "annotations": {
      "list": [
        {
          "builtIn": 1,
          "datasource": {
            "type": "grafana",
            "uid": "-- Grafana --"
          },
          "enable": true,
          "hide": true,
          "iconColor": "rgba(0, 211, 255, 1)",
          "name": "Annotations & Alerts",
          "target": {
            "limit": 100,
            "matchAny": false,
            "tags": [],
            "type": "dashboard"
          },
          "type": "dashboard"
        }
      ]
    },
    "editable": true,
    "fiscalYearStartMonth": 0,
    "graphTooltip": 0,
    "links": [
      {
        "asDropdown": false,
        "icon": "external link",
        "includeVars": false,
        "keepTime": false,
        "tags": [
          "youtube"
        ],
        "targetBlank": false,
        "title": "Navigate",
        "tooltip": "",
        "type": "dashboards",
        "url": ""
      }
    ],
    "liveNow": false,
    "panels": [
      {
        "gridPos": {
          "h": 1,
          "w": 24,
          "x": 0,
          "y": 0
        },
        "id": 28,
        "panels": [],
        "repeat": "channel_info__channel_name",
        "title": "${channel_info__channel_name}",
        "type": "row"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 16,
          "w": 24,
          "x": 0,
          "y": 1
        },
        "id": 10,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: false,\n    splitline_interval: 0\n  },\n  value_axis: {\n    show_values_and_splitline: true,\n    scale_min: true\n  },\n\n  time_reference: 'top',\n  time_reference_description: 'Rank',\n  series_reference: 'video_title',\n  compact_series_text: false,\n  orientation: 'vertical',\n\n  legend: {\n    show: false,\n    table: false,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  disable_emphasis: false,\n\n  stack: true,\n  selectedMode: true,\n  disable_emphasis: true,\n\n  parameters: [\n    {\n      name: 'view_count',\n      queryId: 'A',\n      legend: '',\n      color: [\n        'rgb(126, 178, 109)', // green // '#7EB26D', // 0: pale green\n        'rgb(234, 184, 57)', // semi-dark-yellow // '#EAB839', // 1: mustard\n        'rgb(110, 208, 224)', // light-blue// #6ED0E0', // 2: light blue\n        'rgb(239, 132, 60)', // semi-dark-orange // '#EF843C', // 3: orange\n        'rgb(226, 77, 66)', // red// '#E24D42', // 4: red\n        'rgb(31, 120, 193)', // blue // #1F78C1', // 5: ocean\n        'rgb(186, 67, 169)', // purple // '#BA43A9', // 6: purple\n        'rgb(112, 93, 160)', // #705DA0 // 7: violet\n        'rgb(80, 134, 66)', // dark-green // '#508642', // 8: dark green\n        'rgb(204, 163, 0)', // yellow //'#CCA300', // 9: dark sand\n        'rgb(68, 126, 188)', // #447EBC\n        'rgb(193, 92, 23)', // #C15C17\n        'rgb(137, 15, 2)', // #890F02,\n        'rgb(10, 67, 124)', // #0A437C\n        'rgb(109, 31, 98)', // #6D1F62\n        'rgb(88, 68, 119)', // #584477\n        'rgb(183, 219, 171)', // #B7DBAB\n        'rgb(244, 213, 152)', // #F4D598\n        'rgb(112, 219, 237)', // #70DBED\n        'rgb(249, 186, 143)', // #F9BA8F\n        'rgb(242, 145, 145)', // #F29191\n        'rgb(130, 181, 216)', // #82B5D8\n        'rgb(229, 168, 226)', // #E5A8E2\n        'rgb(174, 162, 224)', // #AEA2E0\n        'rgb(98, 158, 81)', // #629E51\n        'rgb(229, 172, 14)', // #E5AC0E\n        'rgb(100, 176, 200)', // #64B0C8\n        'rgb(224, 117, 45)', // #E0752D\n        'rgb(191, 27, 0)', // #BF1B00\n        'rgb(10, 80, 161)', // #0A50A1\n        'rgb(150, 45, 130)', // #962D82\n        'rgb(97, 77, 147)', // #614D93\n        'rgb(154, 196, 138)', // #9AC48A\n        'rgb(242, 201, 109)', // #F2C96D\n        'rgb(101, 197, 219)', // #65C5DB\n        'rgb(249, 147, 78)', // #F9934E\n        'rgb(234, 100, 96)', // #EA6460\n        'rgb(81, 149, 206)', // #5195CE\n        'rgb(214, 131, 206)', // #D683CE\n        'rgb(128, 110, 183)', // #806EB7\n        'rgb(63, 104, 51)', // #3F6833\n        'rgb(150, 115, 2)', // #967302\n        'rgb(47, 87, 94)', // #2F575E\n        'rgb(153, 68, 10)', // #99440A\n        'rgb(88, 20, 12)', // #58140C\n        'rgb(5, 43, 81)', // #052B51\n        'rgb(81, 23, 73)', // #511749\n        'rgb(63, 43, 91)', // #3F2B5B\n        'rgb(224, 249, 215)', // #E0F9D7\n        'rgb(252, 234, 202)', // #FCEACA\n        'rgb(207, 250, 255)', // #CFFAFF\n        'rgb(249, 226, 210)', // #F9E2D2\n        'rgb(252, 226, 222)', // #FCE2DE\n        'rgb(186, 223, 244)', // #BADFF4\n        'rgb(249, 217, 249)', // #F9D9F9\n        'rgb(222, 218, 247)', // #DEDAF7\n      ],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 1,\n      intensity: '1',\n      type: 'bar',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: true\n    },\n    {\n      name: 'top',\n      queryId: 'A'\n    },\n    {\n      name: 'video_title',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1\n    },\n    areaStyle: {\n      opacity: .2,\n    }\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 2) * series_name_list_aux.length;\n    } else if (series_name_list_without_sum.length <= 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 3.75) * series_name_list_aux.length;\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 3) * series_name_list_aux.length;\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 15;\n        let line_height = 15;\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_top AS (\nSELECT\n  vi.video_title,\n  vs.view_count,\n  RANK() OVER w,\n  SUM(vs.view_count) OVER w,\n  RANK() OVER (PARTITION BY vi.video_title ORDER BY vs.view_count DESC) AS same_title\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nON\n  (vi.channel_id = ci.channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nON\n  (vi.video_id = vs.video_id)\nWHERE\n  $__timeFilter(\"timestamp\") AND\n  ci.channel_name IN ($channel_info__channel_name) AND\n  vs.\"timestamp\" = (SELECT MAX(\"timestamp\") FROM youtube_stats.video_stats WHERE video_id = vi.video_id)\nWINDOW w AS (ORDER BY vs.view_count DESC)\nORDER BY\n  vs.view_count DESC\n), cte_result AS (\nSELECT\n  ct.video_title || (CASE WHEN ct.same_title != 1 THEN ('_' || ct.same_title) ELSE '' END) AS video_title,\n  ct.view_count,\n-- Page-by-page separation using an ad-hoc filter that prevents the list of videos for each page from becoming so large that it exceeds the size of the tooltip.\n  CASE\n    WHEN ct.rank <= 4 THEN 'Page 1'\n    WHEN (ct.sum <= (t.sum * 2)) AND (ct.rank < 20) THEN 'Page 2'\n    WHEN (ct.sum <= (t.sum * 3)) AND (ct.rank < (20 * 1 + 10)) THEN 'Page 3'\n    WHEN (ct.sum <= (t.sum * 4)) AND (ct.rank < (20 * 2 + 10)) THEN 'Page 4'\n    WHEN (ct.sum <= (t.sum * 5)) AND (ct.rank < (20 * 3 + 10)) THEN 'Page 5'\n    WHEN (ct.sum <= (t.sum * 6)) AND (ct.rank < (20 * 4 + 10)) THEN 'Page 6'\n    WHEN (ct.sum <= (t.sum * 7)) AND (ct.rank < (20 * 5 + 10)) THEN 'Page 7'\n    WHEN (ct.sum <= (t.sum * 8)) AND (ct.rank < (20 * 6 + 10)) THEN 'Page 8'\n    WHEN (ct.sum <= (t.sum * 9)) AND (ct.rank < (20 * 7 + 10)) THEN 'Page 9'\n    WHEN (ct.sum <= (t.sum * 10)) AND (ct.rank < (20 * 8 + 10)) THEN 'Page 10'\n    WHEN (ct.sum <= (t.sum * 11)) AND (ct.rank < (20 * 9 + 10)) THEN 'Page 11'\n    WHEN (ct.sum <= (t.sum * 12)) AND (ct.rank < (20 * 10 + 10)) THEN 'Page 12'\n    WHEN (ct.sum <= (t.sum * 13)) AND (ct.rank < (20 * 11 + 10)) THEN 'Page 13'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 12 + 10)) THEN 'Page 14'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 13 + 10)) THEN 'Page 15'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 14 + 10)) THEN 'Page 16'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 15 + 10)) THEN 'Page 17'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 16 + 10)) THEN 'Page 18'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 17 + 10)) THEN 'Page 19'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 18 + 10)) THEN 'Page 20'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 19 + 10)) THEN 'Page 21'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 20 + 10)) THEN 'Page 22'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 21 + 10)) THEN 'Page 23'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 22 + 10)) THEN 'Page 24'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 23 + 10)) THEN 'Page 25'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 24 + 10)) THEN 'Page 26'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 25 + 10)) THEN 'Page 27'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 26 + 10)) THEN 'Page 28'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 27 + 10)) THEN 'Page 29'\n    WHEN (ct.sum <= (t.sum * 14)) AND (ct.rank < (20 * 28 + 10)) THEN 'Page 30'\n    ELSE 'rest'\n  END AS top\nFROM\n  cte_top ct,\n  (SELECT sum FROM cte_top WHERE rank = 4) t\nWHERE\n  ct.view_count <> 0\nORDER BY\n  ct.rank\n)\nSELECT\n  video_title,\n  view_count,\n  top\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n 'no data' AS video_title,\n 0 AS view_count,\n 'Page 0' AS top\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Video List ordered by View Count",
        "transparent": true,
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "fieldConfig": {
          "defaults": {
            "color": {
              "fixedColor": "blue",
              "mode": "fixed"
            },
            "custom": {
              "axisBorderShow": false,
              "axisCenteredZero": false,
              "axisColorMode": "text",
              "axisLabel": "",
              "axisPlacement": "auto",
              "axisSoftMin": 0,
              "fillOpacity": 80,
              "gradientMode": "hue",
              "hideFrom": {
                "legend": false,
                "tooltip": false,
                "viz": false
              },
              "lineWidth": 1,
              "scaleDistribution": {
                "type": "linear"
              },
              "thresholdsStyle": {
                "mode": "off"
              }
            },
            "decimals": 0,
            "mappings": [],
            "thresholds": {
              "mode": "absolute",
              "steps": [
                {
                  "color": "green",
                  "value": null
                }
              ]
            },
            "unit": "locale"
          },
          "overrides": []
        },
        "gridPos": {
          "h": 15,
          "w": 23,
          "x": 0,
          "y": 17
        },
        "id": 133,
        "options": {
          "barRadius": 0,
          "barWidth": 0.97,
          "fullHighlight": false,
          "groupWidth": 0.7,
          "legend": {
            "calcs": [
              "min",
              "mean",
              "max"
            ],
            "displayMode": "table",
            "placement": "bottom",
            "showLegend": true
          },
          "orientation": "auto",
          "showValue": "always",
          "stacking": "none",
          "text": {},
          "tooltip": {
            "mode": "multi",
            "sort": "none"
          },
          "xTickLabelRotation": 0,
          "xTickLabelSpacing": 100
        },
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT\n  vi.video_id,\n  vs.\"timestamp\"::DATE AS day,\n  MAX(vs.view_count) AS view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name IN ($channel_info__channel_name) AND\n  $__timeFilter(vs.\"timestamp\")\nGROUP BY\n  video_id, day\n), cte_lag AS (\nSELECT\n  ct.day,\n  ct.video_id,\n  ct.view_count,\n  LAG(ct.view_count, -1) OVER w AS last_view_count,\n  LAG(ct.day, -1) OVER w AS last_day\nFROM\n  cte_video_list ct\nWINDOW w AS (PARTITION BY ct.video_id ORDER BY ct.day DESC)\n), cte_daily_views AS (\nSELECT\n  cl.video_id,\n  (cl.view_count - cl.last_view_count)/(cl.day - cl.last_day) AS daily_views,\n  TO_CHAR(generate_series(\n-- First day is not taken into account as it is part of the previous window.\n\t  cl.last_day + INTERVAL '1 day',\n    cl.day, INTERVAL '1 day'\n  ),'YYYY-MM-DD') AS day\nFROM\n  cte_lag cl\nWHERE\n  cl.last_view_count IS NOT NULL\n)\nSELECT\n  SUM(daily_views) AS \"Daily Views\",\n  day\nFROM\n  cte_daily_views\nGROUP BY\n  day\nORDER BY\n  day",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Daily Views",
        "transparent": true,
        "type": "barchart"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 14,
          "w": 12,
          "x": 0,
          "y": 32
        },
        "id": 109,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: true,\n    splitline_interval: 0\n  },\n  value_axis: {\n    show_values_and_splitline: false,\n    scale_min: true\n  },\n\n  time_reference: 'week',\n  time_reference_description: 'Week',\n  series_reference: 'year',\n  compact_series_text: false,\n  orientation: 'vertical',\n\n  legend: {\n    show: true,\n    table: true,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  show_zeros: true,\n\n  stack: false,\n  selectedMode: true,\n  disable_emphasis: false,\n\n  parameters: [\n    {\n      name: 'daily_views',\n      queryId: 'A',\n      legend: '',\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 0.8,\n      intensity: '1',\n      type: 'bar',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: true\n    },\n    {\n      name: 'year',\n      queryId: 'A'\n    },\n    {\n      name: 'week',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1,\n      width: 2.25\n    },\n    areaStyle: {\n    },\n    endLabel: {\n      show: true\n    },\n    symbol: 'line',\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 2) * series_name_list_aux.length;\n    } else if (series_name_list_without_sum.length <= 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 3.75) * series_name_list_aux.length;\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 3) * series_name_list_aux.length;\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT DISTINCT\n  vi.video_id,\n  vs.\"timestamp\",\n  vs.view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name IN ($channel_info__channel_name) AND\n  $__timeFilter(vs.\"timestamp\")\n), cte_tag AS (\nSELECT\n  tag,\n  vi.video_id,\n  MAX(vi.view_count) AS view_count\nFROM\n  cte_video_list vi,\n  generate_series (\n    time_bucket(\n      '1 day', \n      (select timezone('Europe/Madrid', $__timeFrom()::timestamp with time zone))\n    ), time_bucket(\n      '1 day', \n      (select timezone('Europe/Madrid', $__timeTo()::timestamp with time zone))\n    ), '1 day'\n  ) tag\nWHERE\n  vi.timestamp >= tag AND\n  vi.timestamp <= tag + interval '1 day'\nGROUP BY\n  tag, vi.video_id\n), cte_lag AS (\nSELECT\n  ct.tag,\n  ct.video_id,\n  ct.view_count,\n  LAG(ct.view_count, -1) OVER w AS last_view_count,\n  LAG(ct.tag, -1) OVER w AS last_tag\nFROM\n  cte_tag ct\nWINDOW w AS (PARTITION BY ct.video_id ORDER BY ct.tag DESC)\n), cte_daily_views AS (\nSELECT\n  cl.tag, \n  cl.video_id,\n  (cl.view_count - cl.last_view_count)/(cl.tag::DATE - cl.last_tag::DATE) AS daily_views\nFROM\n  cte_lag cl\nWHERE\n  cl.last_view_count IS NOT NULL\n), cte_result AS (\nSELECT\n  TO_CHAR(tag, 'YYYY') AS year,\n  AVG(daily_views) AS daily_views,\n-- Add understandability to the data by putting in the month in which the Monday of that week is located\n-- (DATE - DOW) -> Return latest Sunday, but we want to get latest Monday since Week Number (IW) understand the start of the week on Monday\n  TO_CHAR(tag, 'IW') || ' (' || TO_CHAR(tag - INTERVAL '1 day' * MOD((EXTRACT(DOW FROM tag)+6),7), 'FMMonth') || ')' AS week\nFROM\n  cte_daily_views\nGROUP BY \n  TO_CHAR(tag, 'YYYY'),\n  TO_CHAR(tag, 'IW'),\n  TO_CHAR(tag - INTERVAL '1 day' * MOD((EXTRACT(DOW FROM tag)+6),7), 'FMMonth')\nORDER BY\n  TO_CHAR(tag, 'YYYY'),\n  TO_CHAR(tag, 'IW') ASC\n)\nSELECT\n  year,\n  daily_views,\n  week\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n '2000' AS video_title,\n 0 AS daily_views,\n '0' AS week\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Average Daily Views by Week",
        "transparent": true,
        "type": "volkovlabs-echarts-panel"
      },
      {
        "datasource": {
          "type": "grafana-postgresql-datasource",
          "uid": "edk32zh8spnnke"
        },
        "gridPos": {
          "h": 14,
          "w": 12,
          "x": 12,
          "y": 32
        },
        "id": 119,
        "options": {
          "baidu": {
            "callback": "bmapReady",
            "key": ""
          },
          "editor": {
            "format": "auto",
            "height": 600
          },
          "editorMode": "code",
          "gaode": {
            "key": "",
            "plugin": "AMap.Scale,AMap.ToolBar"
          },
          "getOption": "const ECHARTS_TEMPLATE_VERSION = 1.3\n/**\n * INITIAL CONFIGURATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n * Maps query values in Grafana to the values represented in Echarts, along with setting global configuration values for the chart.\n *\n * - tooltip_trigger: 'item' to only show information for the specific bar/line, 'axis' to show all data from the axis.\n *\n * - category_axis: List of options for the category axis (time, days of the week, year, etc.)\n *                  * show_splitline: true/false. Show a separation line between bars.\n *                  * splitline_interval: If the separation line is active, specify after how many bars it should appear (0 = every\n *                                        bar, 1 = every two bars, etc.)\n *                  * axisPointer: 'line' / 'shadow' (displays a shadow or a line when the mouse hovers over) / 'cross'.\n *\n * - value_axis: List of options for the value axis\n *               * show_values_and_splitline: true/false. Show the value axis. If activated, it involves scaling of the chart due\n *                                            to a minor error in Echarts which causes the last line specified by this axis to be the\n *                                            maximum with all its digits. This scaling rounds this last line to the nearest multiple\n *                                            of ten (with exponent relative to the scale being used).\n *               * scale_min: true/false. Replaces the minimum displayed on the chart, usually from 0 to the minimum of the values.\n *                            Helps scale the chart and better distinguish the difference between values, especially for charts where\n *                            the values are very high but then these values are relatively very similar.\n *\n * - time_reference: Name of the column related to the timestamp / day / week ... on which we will group the data.\n *\n * - time_reference_description: Description that will appear on the chart about the type of time reference used (day of the week,\n *                               hour, ...)\n *\n * - series_reference: Name of the column that identifies the series in which data are grouped (as many series as unique values in\n *                     the column). Commonly used to group data by series name/id or temporal references (time slot, day of the week,\n *                     etc.). \n *                     \n *\n * - compact_series_text: true/false. Activate in case the displayed text defining the series is very long. (another option would be\n *                                    to change the 'legend' field if it is too long, or the size of the text itself in the variables\n *                                    textSize, text_size, font-size, fontSize that are throughout the script).\n *\n * - orientation: 'horizontal'/'vertical' orientation of the chart\n *\n * - legend: List of options to configure the legend.\n *           * show: true/false. Flag to show or hide the legend on the panel.\n *           * table: true/false. Display legend as a table with statistics.\n *           * compact_table: If 'true' when there are more than 7 elements in the chart's legend, we switch to having two tables to\n *                            avoid the legend taking up too much space.\n *\n * - number_of_decimals: Number of decimals to show in the chart, legend, tooltip, etc.\n *\n * - number_format: Follow the 'locale' format in whole numbers (comma every three digits), 'locale_dot' (dot instead of comma),\n *                  'short' (simplify numbers into K's, M's, G's, etc.) or null (no format).\n *\n * - show_zeros: If 'true', all metrics, even those with a value of 0, will appear in the tooltip. If 'false', those metrics that do\n *               not have a value for that temporal moment or whose value is 0 will not appear in the tooltip.\n *\n * - stack: If we want to stack the data of all series for this metric (differentiation will still be by colors).\n *\n * - selectedMode: If we want to enable the filtering option by clicking on any of the elements in the legend.\n *\n * - disable_emphasis: Flag that enables/disables emphasis mode in the series when hovering over the legend or data, hiding the rest\n *                     of the data\n *\n * - parameters: Explicitly indicate the columns that we will map from Grafana. Columns already mentioned above in 'time_reference' \n *               and 'series_reference' must also be indicated in this array but only with the 'name' and 'queryId' filled in. For the\n *               rest of the metrics we want to represent on the chart, the following fields need to be filled:\n *\n *               * name: Name of the column.\n *               * queryId: ID of the Grafana query that the column belongs to (default: A, B, C...).\n *               * legend: Additional information that will appear in the chart next to the serie's name in the legend (for example:\n *                         'Number of vehicles in ', 'Number of fines in ', 'Number of people in '...)\n *               * color: List of colors that the chart will use to represent the metric of each serie. It is recommended to have as\n *                        many colors as there are series so that they do not repeat.\n *               * intensity: The color fill intensity of the bar/line (1 = maximum intensity, 0 = transparent).\n *               * type: 'bar' = Bar chart for this metric, 'line' = Line chart for this metric.\n *               * scale_reduction: In case the lines/bars of the chart exceed the chart itself, this value can be adjusted.\n *                                  (scale_reduction > 1 -> reduce scale, scale_reduction < 1 -> increase scale).\n *               * axisIndex: If we want several metrics to be governed by the same scale, we use the same index; if we do not want to\n *                            use the same scale, we use different indices. (for example, if one metric is the number of fined vehicles\n *                            and another metric is the total amount of fines, it makes sense to use different indices since the amount\n *                            of fines will normally have much larger values than the number of vehicles).\n *               * show_label: flag that establishes whether or not the label with the series values is displayed.\n *\n * - no_data_prompt: Default box that will be displayed if no data is available.\n *\n * - bar_type_general_settings: General settings for the bar chart (if used in any metric).\n *\n * - line_type_general_settings: General settings for the line chart (if used in any metric).\n *\n * - label_text_format: Format of the text used to represent the values of each metric and serie.\n *\n *   Note 1: If Grafana does not load the data properly (after checking that you have entered the correct names for mapping)... it is\n *           likely that you do not have the chart option set to 'Table' (instead of 'Time series').\n *   Note 2: The 'series_reference' field must be unique, otherwise there may be issues when sorting the data on the chart.\n *   Note 3: For vertical charts, if the 'name' (description of what that axis represents) is not visible, modify ad-hoc the values in\n *           nameTextStyle.padding (3rd element) / boundaryGap.\n *   Note 4: If you want to hide certain series and only show them if the user clicks on the legend, activate the 'selectedMode'.\n */\n\nconst global_conf = {\n  tooltip_trigger: 'axis',\n  category_axis: {\n    show_splitline: true,\n    splitline_interval: 0\n  },\n  value_axis: {\n    show_values_and_splitline: false,\n    scale_min: true\n  },\n\n  time_reference: 'day',\n  time_reference_description: 'Day',\n  series_reference: 'year',\n  compact_series_text: false,\n  orientation: 'vertical',\n\n  legend: {\n    show: true,\n    table: true,\n    compact_table: false\n  },\n\n  number_of_decimals: 0,\n  number_format: 'locale',\n  show_zeros: true,\n\n  stack: false,\n  selectedMode: true,\n  disable_emphasis: false,\n\n  parameters: [\n    {\n      name: 'daily_views',\n      queryId: 'A',\n      legend: '',\n      color: ['rgb(245,138,120)', 'rgb(108,189,183)', 'rgb(77,126,169)',\n        'rgb(193,98,130)', 'rgb(241,214,165)', 'rgb(144,53,26)',\n        'rgb(174,121,45)', 'rgb(226,192,188)', 'rgb(45,96,72)',\n        'rgb(245,138,120)'],\n      color_gradient: true,\n      color_gradient_diff: 20,\n      color_gradient_start: 0.8,\n      intensity: '1',\n      type: 'bar',\n      scale_reduction: 1.1,\n      axisIndex: '0',\n      show_label: true\n    },\n    {\n      name: 'year',\n      queryId: 'A'\n    },\n    {\n      name: 'day',\n      queryId: 'A'\n    }\n  ],\n  no_data_prommpt: {\n    title: {\n      show: true,\n      textStyle: {\n        color: 'grey',\n        fontSize: 20\n      },\n      text: 'No data',\n      left: 'center',\n      top: 'center'\n    },\n    xAxis: {\n      show: false\n    },\n    yAxis: {\n      show: false\n    },\n    grid: {\n      show: false\n    },\n    tooltip: {\n      show: false\n    },\n    toolbox: {\n      show: false\n    },\n    datazoom: {\n      show: false\n    },\n    series: []\n  },\n  bar_type_general_settings: {\n    type: 'bar',\n    itemStyle: {\n      opacity: 1,\n      borderWidth: 2,\n    }\n  },\n  line_type_general_settings: {\n    type: 'line',\n    itemStyle: {\n      opacity: .9\n    },\n    lineStyle: {\n      opacity: 1,\n      width: 2.25\n    },\n    areaStyle: {\n    },\n    endLabel: {\n      show: true\n    },\n    symbol: 'line',\n  },\n  label_text_format: {\n    textBorderWidth: 0,\n    fontWeight: 'bold',\n    color: '#544848',\n    textBorderColor: '#fff',\n    textBorderWidth: 2\n  }\n};\n\n/**\n * We initialize the configuration for the X-axis and Y-axis.\n * \n * If the chart is horizontal, the Y-axis is responsible for displaying the labels for the time axis; if it is vertical, the X-axis\n * displays the labels for the time axis.\n * \n * The variables 'value_index' and 'category_index' will assist us throughout the script since the value and time reference pairs\n * needed for data representation can have different orders depending on whether the chart is vertical or horizontal:\n * \n *  - vertical: value: index 0, time reference: index 1 (y-axis)\n *  - horizontal: value: index 1, time reference: index 0 (x-axis)\n */\n\nlet xAxis = [];\nlet yAxis = [];\nlet value_index = -1;\nlet category_index = -1;\n\nif (global_conf.orientation == 'horizontal') {\n  yAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 0;\n  category_index = 1;\n} else {\n  xAxis.push({\n    type: 'category',\n    name: global_conf.time_reference_description,\n    nameTextStyle: {\n      verticalAlign: 'bottom',\n      padding: [0, 0, -35, -30]\n    },\n    splitLine: {\n      show: global_conf.category_axis.show_splitline,\n      lineStyle: {\n        type: \"dashed\",\n      },\n      interval: global_conf.category_axis.splitline_interval\n    },\n    axisLabel: {\n      hideOverlap: true\n    }\n  });\n  value_index = 1;\n  category_index = 0;\n}\n\n/* We check that there are no misconfigured variables. */\nif (global_conf.number_of_decimals < 0) {\n  throw Error('number_of_decimals: configuración inválida')\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * HELPER FUNCTIONS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * List of helper functions used to enrich and/or format data visualization with Apache Echarts:\n *  - rgbLight: Function that takes an input RGB color and returns a lighter variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - rgbDark:  Function that takes an input RGB color and returns a darker variant (depending on gradient_diff) and with a specific\n *              intensity (intensity).\n *  - numberToShortFormat: Function that converts a numeric value into its abbreviated form such as 1K, 1M, etc.\n *  - numberFormat: Formatting of metrics according to the globally configured value (number_format).\n *  - addSum: If the stack option has been set to 'true', this helps calculate the total accumulated in the sum_stack structure for all\n *            series on a metric, with the final value displayed at the end of each bar.\n *  - getMax: Used if you want to have a 'splitLine' for the value axis to prevent the last line from being a non-round number (not a\n *            multiple of 10). It takes the maximum value and rounds it to the next multiple of 10 (adjusted to the scale being used).\n *  - getMin: Used to obtain the minimum value to be represented, thus scaling the chart to this value.\n *  - compareInterval:  Helper function that compares two time intervals (a, b), both in HH:MM:SS format, and returns an integer value\n *                      of the difference between them. It is used for ordering series of times.\n */\n\nfunction rgbLight(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] + gradient_diff > 255) ? 255 : rgb_aux[0] + gradient_diff, \", \",\n    (rgb_aux[1] + gradient_diff > 255) ? 255 : rgb_aux[1] + gradient_diff, \", \",\n    (rgb_aux[2] + gradient_diff > 255) ? 255 : rgb_aux[2] + gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction rgbDark(rgb, gradient_diff, intensity) {\n  let rgb_aux = rgb.replace(/[^\\d,]/g, '').split(',').map(Number);\n  return \"rgb(\".concat(\n    (rgb_aux[0] - gradient_diff < 0) ? 0 : rgb_aux[0] - gradient_diff, \", \",\n    (rgb_aux[1] - gradient_diff < 0) ? 0 : rgb_aux[1] - gradient_diff, \", \",\n    (rgb_aux[2] - gradient_diff < 0) ? 0 : rgb_aux[2] - gradient_diff, \", \",\n    intensity, \")\"\n  );\n}\n\nfunction numberToShortFormat(value) {\n  /* List of suffixes for abbreviated formatting */\n  let suffixes = [\"\", \"K\", \"M\", \"B\", \"T\"];\n\n  /* If no decimals are to be displayed and the value 999 or less is present, it is not formatted. */\n  if (global_conf.number_of_decimals == 0 && Math.floor((\"\" + value).length < 4)) {\n    return value\n  }\n\n  /* We calculate the suffix that corresponds to the value */\n  let suffixNum = Math.floor((\"\" + parseInt(value)).length / 3);\n\n  /* We divide by the base power 1000 equivalent to the suffixNum and apply the precision to the resultltado */\n  let shortValue = suffixNum != 0 ? (value / Math.pow(1000, suffixNum)) : value;\n  shortValue = parseFloat(shortValue.toPrecision(Math.floor((\"\" + value).length + global_conf.number_of_decimals)));\n  if (shortValue % 1 != 0) {\n    shortValue = shortValue.toFixed(global_conf.number_of_decimals);\n  }\n\n  return (suffixNum > 4) || Number.parseFloat(shortValue).toPrecision(1) == '0' ? shortValue : shortValue + suffixes[suffixNum];\n}\n\nfunction numberFormat(value) {\n  let result = value;\n  switch (global_conf.number_format) {\n    case 'locale':\n      result = value.toLocaleString();\n      break;\n    case 'locale_dot':\n      result = value.toLocaleString('de-DE');\n      break;\n    case 'short':\n      result = numberToShortFormat(value);\n      break;\n    default:\n  }\n  return result;\n}\n\nlet sum_stack = {}\nfunction addSum(query_index, parameter_index, date, value) {\n  /**\n   * Before adding the corresponding value for each query, metric, and temporal reference,\n   * we need to check if the key exists (and if it does not exist, create it:\n   *                                        Query: sum_stack[query_index] = {}\n   *                                        Metric: sum_stack[query_index][parameter_index] = {}\n   *                                        Temporal Reference: sum_stack[query_index][parameter_index][x[category_index]] = x[value_index]).\n   * Example of the final structure:\n   * sum_stack = {\n   *    fines: {\n   *      num_fines: {\n   *        Sunday: 58,\n   *        Thursday: 69,\n   *        Monday: 51,\n   *         ...\n   *      }\n   *    },\n   *    vehicles: {\n   *      num_vehicles: {\n   *        Sunday: 74,\n   *        Thursday: 78,\n   *        Monday: 70,\n   *        ...\n   *      }\n   *    }\n   *  }\n   */\n  if (!(query_index in sum_stack)) {\n    sum_stack[query_index] = {}\n  }\n  if (!(parameter_index in sum_stack[query_index])) {\n    sum_stack[query_index][parameter_index] = {}\n  }\n  if (!(date in sum_stack[query_index][parameter_index])) {\n    sum_stack[query_index][parameter_index][date] = 0;\n  }\n  sum_stack[query_index][parameter_index][date] += value;\n}\n\nfunction getMax(value, scale_reduction) {\n  /*\n   * Returns the largest integer obtained by first dividing by the pow of 10 times length, with a Math.ceil, and then multiplying by\n   * the pow of 10 times length, applied to the product value.max * scale_reduction. multiply by the pow of 10 times length, applied\n   * to the product value.max * scale_reduction. \n   * Example:\n   *  - value.max = 19731\n   *  - scale_reduction = 1\n   *  - pow = 3 ( parseInt(19731 * 1).length - 2 )\n   *  - Math.ceil((19731 * 1) / Math.pow(1000, 1)) = Math.ceil (19.73) = 20\n   *  - return = 20000\n   */\n  if (!!global_conf.value_axis.show_values_and_splitline) {\n    // Calcula el exp de la potencia base 10 en función del valor\n    let pow = (\"\" + parseInt(value.max * scale_reduction)).length;\n    if (pow > 4) {\n      pow -= 2;\n    } else if (pow > 1 && pow <= 4) {\n      pow -= 1;\n    }\n    return Math.ceil((value.max * scale_reduction) / Math.pow(10, pow)) * Math.pow(10, pow);\n  } else {\n    return Math.floor(Math.max(value.max * scale_reduction + 1, 0));;\n  }\n}\n\nfunction getMin(value) {\n  /*\n   * Returns the maximum between::\n   * - 0\n   * - the integer (less than or equal to) obtained by first dividing by the pow of 10 with a Math.floor, and then multiplying by\n   *   the pow of 10, applied to the min value.\n   * Example:\n   * - value.min = 10979.54\n   * - pow: 4\n   * - return = 10000\n   */\n  if (!!global_conf.value_axis.scale_min) {\n    /* Calculates the exponential of the power base 10 as a function of the value */\n    let pow = parseInt(value.min).toString().length - 1\n\n    return Math.max(0, Math.floor(value.min / Math.pow(10, pow)) * Math.pow(10, pow));\n  } else {\n    return 0\n  }\n}\n\nfunction compareInterval(a, b) {\n  /* We convert the interval HH:MM:SS-hh:mm:ss to the integer formed by HHMMSS */\n  let result = parseInt(a.split('-')[0].replace(':', '')) - parseInt(b.split('-')[0].replace(':', ''));\n  return result\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA MAPPING & GROUPING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We extract the data we get in Grafana from the query. Example:\n * raw_data = {\n *    fines: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_fines: [22, 22, 28, ...]\n *    },\n *    vehicles: {\n *        day: ['Sunday', 'Saturday', 'Friday', ...],\n *        device: ['Madrid', 'Madrid', 'Madrid', ...],\n *        num_vehicles: [23, 25, 24, ...]\n *    }\n * }\n */\n\nconst raw_data = {}\nconst data = context.panel.data;\ndata.series.map((s) => {\n  global_conf.parameters.map((parameter) => {\n    if (parameter.queryId === s.refId) {\n      if (!(parameter.queryId in raw_data)) {\n        raw_data[parameter.queryId] = {};\n      }\n      raw_data[parameter.queryId][parameter.name] = s.fields.find((f) => (f.name === parameter.name && s.refId === parameter.queryId)).values;\n    }\n  });\n});\n\n/* If stacking is present, a 'phantom' array is added to display the total sum at the end of each bar: a 0 value at the end of each\n * metric array, a default value at the end of the time array and '__sum_stack' in the serie array. metric array, a default value\n * at the end of the time array and '__sum_stack' in the serie array. */\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        global_conf.stack) {\n        raw_data[query_index][parameter_index] = [...raw_data[query_index][parameter_index], 0]\n      }\n    }\n  }\n  if (global_conf.stack) {\n    raw_data[query_index][global_conf.time_reference] = [...raw_data[query_index][global_conf.time_reference], raw_data[query_index][global_conf.time_reference][0]]\n    raw_data[query_index][global_conf.series_reference] = [...raw_data[query_index][global_conf.series_reference], '__sum_stack']\n  }\n}\n\n/* Indexes must always be incremental, there cannot be a series with axisIndex: 1 if there is no other series with axisIndex: 0. To\n * control this error, we create a 'dictionary' that maps the values of the indexes that we have indicated in the initial configuration\n * with values that avoid the error. */\n\nlet index_aux = 0;\nlet index_map = {};\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [gconf_parameter_index, gconf_parameter] of global_conf.parameters.entries()) {\n      if (parameter_index === gconf_parameter.name &&\n        parameter_index !== global_conf.time_reference &&\n        parameter_index !== global_conf.series_reference &&\n        !(gconf_parameter.axisIndex in index_map)) {\n        index_map[gconf_parameter.axisIndex] = index_aux;\n        index_aux += 1;\n      }\n    }\n  }\n}\n\n/* If we do not have any data, we indicate it and exit the script. */\n\nif (Object.keys(raw_data).length == 0) {\n  return global_conf.no_data_prommpt;\n}\nfor (const query in raw_data) {\n  if (Object.keys(raw_data[query]).length == 0) {\n    return global_conf.no_data_prommpt;\n  }\n  for (const parameter in raw_data[query]) {\n    if (raw_data[query][parameter].length == 0) {\n      return global_conf.no_data_prommpt;\n    }\n  }\n}\n\n/**\n * We group the metrics by serie and map each value to its time reference. Example:\n * processed_data = {\n *    fines: {\n *        num_fines: {\n *            Madrid: [[22, 'Sunday'], [22, 'Saturday'], [28, 'Friday'], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    },\n *    vehicles: {\n *        num_vehicles: {\n *            Madrid: [[23, 'Sunday'], [25, 'Saturday'], [24, 'Friday], ...],\n *            Toledo: [...],\n *            ...\n *        }\n *    }\n * }\n */\n\nconst processed_data = {}\n\nfor (const [query_index, query] of Object.entries(raw_data)) {\n  for (const [parameter_index, parameter] of Object.entries(raw_data[query_index])) {\n    if (parameter_index !== global_conf.time_reference && parameter_index !== global_conf.series_reference) {\n      if (!(query_index in processed_data)) {\n        processed_data[query_index] = {}\n      }\n      processed_data[query_index][parameter_index] = {}\n      raw_data[query_index][global_conf.series_reference].map((serie, serie_index) => {\n        if (!(serie in processed_data[query_index][parameter_index])) {\n          processed_data[query_index][parameter_index][serie] = []\n        }\n        let pair_aux = [0, 0];\n        pair_aux[value_index] = Math.round(raw_data[query_index][parameter_index][serie_index] * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals);\n        pair_aux[category_index] = raw_data[query_index][global_conf.time_reference][serie_index];\n        processed_data[query_index][parameter_index][serie].push(pair_aux);\n      });\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA CLEANSING\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n *\n */\n\n/* Insertar ceros para fechas que no tenemos datos */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  let times_set = Array.from([...new Set(raw_data[query_index][global_conf.time_reference])]).sort(compareInterval);\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    for (const [serie_index, serie] of Object.entries(parameter)) {\n      let full_serie = []\n      for (const [time_index, time] of times_set.entries()) {\n        let pair_aux = [0, 0];\n        pair_aux[category_index] = time;\n\n        for (j = 0; j < serie.length; j++) {\n          let category = serie[j][category_index]\n          let value = serie[j][value_index]\n\n          if (category == time) {\n            pair_aux[value_index] = value\n            break;\n          }\n        }\n        full_serie.push(pair_aux)\n      }\n      processed_data[query_index][parameter_index][serie_index] = full_serie\n    }\n  }\n}\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * DATA VISUALIZATION\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the variables with which we are going to represent the data, following the initial configuration defined.\n * \n * - seriesData: Array where we are going to insert the configuration for each metric/serie.\n * \n * - legendTable: Legend/table shown below the graph to indicate metric name + serie and statistical data.\n * \n * - series_name_to_processed_data: Translator that will be used in the formatter functions to obtain the indexes and access\n *                                  the different elements of our arrays with data (processed_data, raw_data, etc.) from a\n *                                  seriesName.\n * \n * - sum_stack_finished:  Reset Trigger. It detects any user action (such as clicking on the legend to activate the filtering)\n *                        to reset the summation and thus re-sum all visible bars/lines.\n */\n\nlet seriesData = [];\nlet legendTable = [];\nlet series_name_to_processed_data = {};\nlet sum_stack_finished = {};\nif (global_conf.stack) {\n  Object.keys(processed_data).map((query) => {\n    sum_stack_finished[query] = {};\n    let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n    Object.keys(processed_data[query]).map((parameter) => {\n      sum_stack_finished[query][parameter] = {};\n      for (const [time_index, time] of times_set.entries()) {\n        sum_stack_finished[query][parameter][time] = false;\n      }\n    });\n  });\n}\n\n/* We traverse processed_data by query. Note: Object.entries is a way to avoid accessing references rather than primitive values */\nfor (const [query_index, query] of Object.entries(processed_data)) {\n  /* 'series_set' will allow us for each query to go through the data by serie (we discriminate by query as it may be the case\n   * that a serie has data for the results of a query but for another query it has no data, so we are more selective). */\n  let series_set = [...new Set(raw_data[query_index][global_conf.series_reference])];\n  /* Recorremos la query por métricas */\n  for (const [parameter_index, parameter] of Object.entries(query)) {\n    /* We get the configuration indicated at the beginning of the script for this metric. Note: With Object.assign we get a shallow\n     * copy of the configuration, so we avoid working with references in a loop, the 'let' initialisation also helps to solve this\n     * problem. */\n    let conf = Object.assign({}, global_conf.parameters.find((f) => (f.name === parameter_index && f.queryId === query_index)));\n    let legend_name = conf.legend;\n    /* We add a new element to the data axis applying the scale reduction if it corresponds to it.\n     * The 1 we add in scale_reduction is to avoid that in graphs where the values represented are small values (1, 2, etc.), the\n     * 'scale_reduction' factor does not have much influence and it is very likely that the label is still not seen as the slash is \n     * too long. */\n\n    if (global_conf.orientation == 'horizontal') {\n      xAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    } else {\n      yAxis.push({\n        name: legend_name,\n        nameTextStyle: {\n          /* We do not want it to appear on the value axis, as the 'legend_name' already appears in the legend itself. */\n          color: 'rgb(0,0,0,0)'\n        },\n        show: (global_conf.value_axis.show_values_and_splitline) ? true : false,\n        type: 'value',\n        max: function (value) { return getMax(value, conf.scale_reduction) },\n        min: function (value) { return getMin(value) },\n        splitLine: {\n          show: (global_conf.value_axis.show_values_and_splitline) ? true : false\n        },\n        axisLabel: {\n          formatter: function (value, index) {\n            return numberFormat(value);\n          },\n          color: 'rgb(40, 50, 60, 0.8)'\n        }\n      });\n    }\n    /* We go through the metrics by serie */\n    for (const [serie_index, serie] of series_set.entries()) {\n      /* We create the configuration for this metric and serie */\n      let color = conf.color[serie_index % conf.color.length];\n      let intensity = conf.intensity;\n      /* Object to be used in the formatter functions to obtain the indexes and access to the different elements of processed_data\n       * and raw_data from a seriesName. */\n      series_name_to_processed_data[query_index + parameter_index + serie] = {\n        \"show_text\": (serie.length > 30 && global_conf.compact_series_text) ? legend_name.slice(0, 3) + '... ' + serie.slice(0, 30) + '...' : legend_name + serie,\n        \"query_index\": query_index,\n        \"parameter_index\": parameter_index,\n        \"serie\": serie\n      };\n      /* Depending on whether it is configured as a line chart or bar chart we apply some changes or others 'series_aux' will be\n       * the series that will be inserted to the array 'seriesData'.  */\n      if (conf.type === 'line') {\n        if (serie == '__sum_stack') {\n          color = 'rgb(0,0,0,0)';\n        }\n        series_aux = global_conf.line_type_general_settings;\n        series_aux.itemStyle.color = color;\n        if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.areaStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.areaStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.areaStyle.borderColor = color;\n        }\n      } else {\n        series_aux = global_conf.bar_type_general_settings;\n        if (serie == '__sum_stack') {\n          series_aux.itemStyle.color = 'rgb(255,255,255,0.0)';\n        } else if (conf.color_gradient == true) {\n          let color_light = rgbLight(color, conf.color_gradient_diff, intensity);\n          let color_dark = rgbDark(color, conf.color_gradient_diff, intensity);\n\n          series_aux.itemStyle.color = {\n            type: 'linear',\n            x: (global_conf.orientation == 'vertical') ? 0 : 1,\n            y: 0,\n            x2: 0,\n            y2: (global_conf.orientation == 'vertical') ? 1 : 0,\n            global: false,\n            colorStops: [\n              {\n                offset: 0,\n                color: color_light\n              },\n              {\n                offset: conf.color_gradient_start,\n                color: color_dark\n              }\n            ]\n          };\n        } else {\n          series_aux.itemStyle.color = color.substring(0, color.length - 1) + ',' + intensity + ')';\n          series_aux.itemStyle.borderColor = color;\n        }\n      }\n      /* We define the alias, assign the processed data and the index to the series. */\n      series_aux.name = query_index + parameter_index + serie;\n      series_aux.data = parameter[serie];\n      if (global_conf.orientation == 'horizontal') {\n        series_aux.xAxisIndex = index_map[conf.axisIndex];\n      } else {\n        series_aux.yAxisIndex = index_map[conf.axisIndex];\n      }\n      /* For this metric and serie we calculate the mean, minimum and maximum taking into account the values in all time\n       * references. */\n      let data_aux = parameter[serie].map((x) => x[value_index]);\n      if (data_aux.length == 0) {\n        mean = 0;\n        min = 0;\n        max = 0;\n      } else {\n        mean = numberFormat(Math.round((data_aux.reduce((a, b) => a + b) / data_aux.length) * (10 ** global_conf.number_of_decimals)) / (10 ** global_conf.number_of_decimals));\n        min = numberFormat(Math.min(...data_aux));\n        max = numberFormat(Math.max(...data_aux));\n      }\n      /* After doing the calculations we prepare the text to be displayed in the legend table. Note: If the serie name is\n       * too large, the text is trimmed so that there is no overlapping text.. */\n      let serie_text = (serie.length > 30 && global_conf.compact_series_text) ? ('{serie_small|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}') : ('{serie|' + series_name_to_processed_data[query_index + parameter_index + serie]['show_text'] + '}');\n      legendTable.push({\n        legend_name: query_index + parameter_index + serie,\n        data: [serie_text +\n          '{value|' + min + '}' +\n          '{value|' + max + '}' +\n          '{value|' + mean + '}'\n        ]\n      });\n      /* The series is added to the array. To avoid adding any references to the series array, use this JSON.stringify 'trick'. */\n      seriesData.push(JSON.parse(JSON.stringify(series_aux)));\n      /* As JSON.stringify does not allow copying functions, and we will need functions to configure how we want to display\n       * the metric values depending on whether stacking/stacking is done or not, we modify the series after inserting it\n       * into the array */\n      if (global_conf.stack) {\n        /* To identify each stacking/grouping, we assign it the name of the query and the name of the metric */\n        seriesData[seriesData.length - 1].stack = query_index + '_' + parameter_index;\n        /* If stacking is present, the total accumulated value (stored in sum_stack) is represented in the last element of\n         * the bar/line, in the rest of the lines/bars no value is represented. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!conf.show_label) {\n                return '';\n              }\n\n              let data_aux = series_name_to_processed_data[params['seriesName']];\n              /*  Reset the count to re-summarise the stack. */\n              if (sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] == false) {\n                addSum(data_aux['query_index'], data_aux['parameter_index'], params['data'][category_index], params['data'][value_index]);\n              }\n              if (data_aux['serie'] == '__sum_stack') {\n                sum_stack_finished[data_aux['query_index']][data_aux['parameter_index']][params['data'][category_index]] = true;\n                let number_aux = sum_stack[data_aux['query_index']][data_aux['parameter_index']][params.data[category_index]];\n                if (!!!global_conf.show_zeros && number_aux == 0) {\n                  return '';\n                } else {\n                  return '{total|' + numberFormat(number_aux) + '}';\n                }\n              } else {\n                return '';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        };\n      } else {\n        /* If there is no stacking, the value is represented on each bar/line and nothing needs to be calculated for sum_stack. */\n        seriesData[seriesData.length - 1].label = {\n          normal: {\n            show: conf.show_label,\n            formatter: (params) => {\n              if (!!!global_conf.show_zeros && params.value[value_index] == 0) {\n                return '';\n              } else {\n                return '{total|' + numberFormat(params.value[value_index]) + '}';\n              }\n            },\n            rich: {\n              total: global_conf.label_text_format\n            }\n          }\n        }\n      }\n      /* Depending on whether the graph is vertical/horizontal it is better to place the value to the right or above each bar/line. */\n      if (global_conf.orientation == 'horizontal') {\n        seriesData[seriesData.length - 1].label.normal.position = 'right';\n      } else {\n        seriesData[seriesData.length - 1].label.normal.position = 'top';\n      }\n    }\n  }\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * EVENT LISTENERS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * Programmed actions that are triggered when a given event is activated.\n *  - legendselectchanged:  When an item is clicked in the legend for the purpose of filtering by series. The action is to reset all\n *                          counts to 0 if stacking is enabled (so that the summation is recalculated).\n */\ncontext.panel.chart.off(\"legendselectchanged\");\ncontext.panel.chart.on(\"legendselectchanged\", (params) => {\n  if (global_conf.stack && global_conf.selectedMode) {\n    Object.keys(processed_data).map((query) => {\n      let times_set = [...new Set(raw_data[query][global_conf.time_reference])];\n      Object.keys(processed_data[query]).map((parameter) => {\n        for (const [time_index, time] of times_set.entries()) {\n          sum_stack_finished[query][parameter][time] = false;\n          sum_stack[query][parameter][time] = 0;\n        }\n      });\n    });\n    /* Trick to update the entire graph and force the sum to be recalculated */\n    context.panel.chart.setOption({});\n  }\n});\n\n\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n/**\n * LEGEND DESIGN WITH STATISTICS\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We initialise the values we are going to use to place and represent the legend.\n * \n * - bottom_grid: Position where the bar/line graph starts.\n * - bottom_legend_head: Position of the legend title (serie name, max, min, mean...)\n * - config_legend_head: Configuration of the legend title text.\n * - config_legend_table: List of metrics/series with their statistics.\n * - series_name_list_splitted:   Used in case in the initial configuration 'compact_legend' is true and there are more than 7\n *                                elements in the table. \n * - legend_alignment: Configuration for the alignment of the table.\n */\nlet config_legend_head = [];\nlet config_legend_table = [];\nlet bottom_grid = 0;\nlet bottom_legend_head = 0;\nlet series_name_list_splitted = [];\nif (global_conf.legend.table == true) {\n  /* Ad-hoc configuration to adjust legend and graph according to the number of elements to avoid legend and graph overlap.\n   * They will be different depending on whether the graph is vertical/horizontal or whether 'compact_legend' is true/false. */\n  let legend_alignment = {\n    bottom_legend: '0%',\n    textSize_small: 12,\n    textGap: 3,\n    head_margin: 7\n  };\n  /*  series_name_list_without_sum:   List of 'seriesName' of the previously created series (without the 'ghost'\n                                      series __sum_stack which only serves to fix the summation in case of stacking).  */\n  series_name_list_without_sum = Object.keys(series_name_to_processed_data).filter((series_name) =>\n    series_name_to_processed_data[series_name]['serie'] != '__sum_stack');\n  if (global_conf.orientation == 'horizontal') {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 0.75;\n    } else {\n      legend_alignment.grid_margin = 0;\n    }\n  } else {\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      legend_alignment.grid_margin = 1.75;\n    } else {\n      legend_alignment.grid_margin = 1;\n    }\n  }\n  /* In case 'compact_legend' is true and there are more than 7 elements, the legend shall be divided into two tables on each side */\n  if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n    series_name_list_splitted = [series_name_list_without_sum.slice(0, (series_name_list_without_sum.length + 1) / 2),\n    series_name_list_without_sum.slice((series_name_list_without_sum.length + 1) / 2, series_name_list_without_sum.length)];\n    legend_alignment.textSize = 12;\n    legend_alignment.table_width = 400;\n  } else {\n    series_name_list_splitted = [series_name_list_without_sum];\n    legend_alignment.textSize = 13;\n    legend_alignment.table_width = 600;\n  }\n  /* textHeight' will be used to calculate the size of the table depending on the number of elements in the table. */\n  legend_alignment.textHeight = legend_alignment.textSize + legend_alignment.textGap * 2.25;\n\n  /* Loop needed to display two tables in case 'compact_legend' is true and there are more than 7 elements. */\n  for (const [series_name_list_aux_index, series_name_list_aux] of series_name_list_splitted.entries()) {\n    /* Ad-hoc setting to determine the end of the table and the start of the table title */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 2) * series_name_list_aux.length;\n    } else if (series_name_list_without_sum.length <= 7 && global_conf.legend.compact_table) {\n      bottom_legend_head = (legend_alignment.textHeight - 3.75) * series_name_list_aux.length;\n    } else {\n      bottom_legend_head = (legend_alignment.textHeight - 5) * series_name_list_aux.length;\n    }\n    config_legend_head_aux = {\n      show: global_conf.legend.show,\n      /* We avoid duplicates, we only show one legend that will encompass all series. */\n      data: [series_name_list_aux[0]],\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode,\n      icon: 'none',\n      bottom: bottom_legend_head,\n      orient: 'vertical',\n      formatter: '{serieHead|}{valueHead|Min}{valueHead|Max}{valueHead|Mean}\\n{hr|}\\n',\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          hr: {\n            borderColor: '#777',\n            width: '100%',\n            borderWidth: 0.5,\n            height: 0\n          },\n          serieHead: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize\n          },\n          valueHead: {\n            color: 'rgb(31, 98, 224)',\n            width: '13%',\n            align: 'right',\n            padding: [0, 0, 0, 0],\n            fontWeight: \"bold\",\n            fontSize: legend_alignment.textSize\n          }\n        }\n      }\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_head_aux.left = 'left';\n      } else {\n        config_legend_head_aux.right = 'left';\n      }\n    } else {\n      config_legend_head_aux.left = 'center';\n    }\n    config_legend_head.push(config_legend_head_aux);\n    config_legend_table_aux = {\n      show: global_conf.legend.show,\n      data: series_name_list_aux,\n      orient: 'vertical',\n      bottom: legend_alignment.bottom_legend,\n      icon: 'circle',\n      formatter: function (value) {\n        /* Thanks to the array legendTable we map the data name to the text. */\n        return legendTable.find((f) => f.legend_name === value).data;\n      },\n      itemGap: legend_alignment.textGap,\n      textStyle: {\n        width: legend_alignment.table_width,\n        rich: {\n          serie: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          serie_small: {\n            width: '50%',\n            align: 'left',\n            fontSize: legend_alignment.textSize,\n            fontFamily: 'Trebuchet MS'\n          },\n          value: {\n            width: '13%',\n            fontSize: legend_alignment.textSize,\n            align: 'right',\n            fontFamily: 'Trebuchet MS'\n          }\n        }\n      },\n      /* When you click on it, it does nothing */\n      selectedMode: global_conf.selectedMode\n    };\n    /* If there are two boards, place one on the left and one on the right, otherwise place the board in the middle. */\n    if (series_name_list_without_sum.length > 7 && global_conf.legend.compact_table) {\n      if (series_name_list_aux_index == 0) {\n        config_legend_table_aux.left = 'left';\n      } else {\n        config_legend_table_aux.right = 'left';\n      }\n    } else {\n      config_legend_table_aux.left = 'center';\n    }\n    config_legend_table.push(config_legend_table_aux);\n  }\n  /* Ad-hoc configuration to determine the end of the table and the start of the chart */\n  bottom_grid = legend_alignment.textHeight * (series_name_list_splitted[0].length + legend_alignment.grid_margin);\n} else {\n  bottom_grid = '7%';\n  config_legend = {\n    show: global_conf.legend.show,\n    top: 'bottom',\n    selectedMode: global_conf.selectedMode,\n    formatter: function (name) {\n      if (series_name_to_processed_data[name]['serie'] == '__sum_stack') {\n        return '';\n      } else {\n        return series_name_to_processed_data[name]['show_text'];\n      }\n    }\n  };\n}\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */\n\n\n\n/**\n * ECHARTS DESIGN\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n * \n * We return the data visualisation elements to be displayed in the Grafana dashboard  (panel title, panel grid, X-axis, Y-axis,\n * data series, legend, tooltip, toolbox, toolbox, datazoom, etc.)\n * \n */\n\nreturn {\n  grid: [{\n    top: '4%',\n    bottom: bottom_grid,\n    containLabel: true,\n    left: (global_conf.orientation == 'vertical') ? '1%' : '2%',\n    right: (global_conf.orientation == 'vertical') ? '4%' : '4%'\n  }],\n\n  legend: (global_conf.legend.table) ? [config_legend_head, config_legend_table].flat(1) : config_legend,\n\n  emphasis: {\n    disabled: global_conf.disable_emphasis,\n    focus: 'series'\n  },\n\n  tooltip: {\n    trigger: global_conf.tooltip_trigger,\n    valueFormatter: ((value) => {\n      return numberFormat(value)\n    }),\n    formatter: ((params) => {\n      if (Array.isArray(params)) {\n        let text_size = 0;\n        let line_height = 0;\n        if (params.length > 28) {\n          text_size = 10;\n          line_height = 10;\n        } else if (params.length > 15) {\n          text_size = 12;\n          line_height = 12;\n        } else {\n          text_size = 15;\n          line_height = 15;\n        }\n        string_aux = [`<div style=\"line-height: ${line_height}px;\">`, params[0].axisValue];\n        params.map((item) => {\n          if ((series_name_to_processed_data[item['seriesName']]['serie'] != '__sum_stack') && (global_conf.show_zeros || item.value[value_index] != 0)) {\n            string_aux = [...string_aux, `<br>${item.marker}<span style=\"font-size:${text_size}px\">${series_name_to_processed_data[item.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:${text_size}px\">${numberFormat(item.value[value_index])}</span>`];\n          }\n        });\n        return [...string_aux, '</div>'].join('\\n');\n      } else {\n        return [params.value[category_index], `<br>${params.marker}<span style=\"font-size:15px\">${series_name_to_processed_data[params.seriesName]['show_text']}</span><span style=\"float: right; margin-left: 20px; font-weight:bold; font-size:15px\">${numberFormat(params.value[value_index])}</span>`].join('\\n');\n      }\n    }),\n    axisPointer: {\n      label: {\n        precision: global_conf.number_of_decimals\n      },\n      type: global_conf.category_axis.axisPointer\n    }\n  },\n\n  yAxis: yAxis,\n\n  xAxis: xAxis,\n\n  series: seriesData\n};\n/**\n * --------------------------------------------------------------------------------------------------------------------------\n * --------------------------------------------------------------------------------------------------------------------------\n */",
          "google": {
            "callback": "gmapReady",
            "key": ""
          },
          "map": "none",
          "renderer": "canvas",
          "themeEditor": {
            "config": "{}",
            "height": 400,
            "name": "default"
          },
          "visualEditor": {
            "code": "return {\n  dataset: context.editor.dataset,\n  series: context.editor.series,\n  xAxis: {\n    type: 'time',\n  },\n  yAxis: {\n    type: 'value',\n    min: 'dataMin',\n  },\n}\n",
            "dataset": [],
            "series": []
          }
        },
        "pluginVersion": "6.0.0",
        "targets": [
          {
            "datasource": {
              "type": "postgres",
              "uid": "edk32zh8spnnke"
            },
            "editorMode": "code",
            "format": "table",
            "group": [],
            "metricColumn": "none",
            "rawQuery": true,
            "rawSql": "WITH cte_video_list AS (\nSELECT DISTINCT\n  vi.video_id,\n  vs.\"timestamp\",\n  vs.view_count\nFROM\n  youtube_stats.channel_info ci\nINNER JOIN\n  youtube_stats.video_info vi\nUSING\n  (channel_id)\nINNER JOIN\n  youtube_stats.video_stats vs\nUSING\n  (video_id)\nWHERE\n  ci.channel_name IN ($channel_info__channel_name) AND\n  $__timeFilter(vs.\"timestamp\")\n), cte_tag AS (\nSELECT\n  tag,\n  vi.video_id,\n  MAX(vi.view_count) AS view_count\nFROM\n  cte_video_list vi,\n  generate_series (\n    time_bucket(\n      '1 day', \n      (select timezone('Europe/Madrid', $__timeFrom()::timestamp with time zone))\n    ), time_bucket(\n      '1 day', \n      (select timezone('Europe/Madrid', $__timeTo()::timestamp with time zone))\n    ), '1 day'\n  ) tag\nWHERE\n  vi.timestamp >= tag AND\n  vi.timestamp <= tag + interval '1 day'\nGROUP BY\n  tag, vi.video_id\n), cte_lag AS (\nSELECT\n  ct.tag,\n  ct.video_id,\n  ct.view_count,\n  LAG(ct.view_count, -1) OVER w AS last_view_count,\n  LAG(ct.tag, -1) OVER w AS last_tag\nFROM\n  cte_tag ct\nWINDOW w AS (PARTITION BY ct.video_id ORDER BY ct.tag DESC)\n), cte_daily_views AS (\nSELECT\n  cl.tag,\n  cl.video_id,\n  (cl.view_count - cl.last_view_count)/(cl.tag::DATE - cl.last_tag::DATE) AS daily_views\nFROM\n  cte_lag cl\nWHERE\n  cl.last_view_count IS NOT NULL\n), cte_result AS (\nSELECT\n  TO_CHAR(tag, 'YYYY') AS year,\n  AVG(daily_views) AS daily_views,\n  TO_CHAR(tag, 'Day') AS day,\n  EXTRACT(DOW FROM tag) AS dow\nFROM\n  cte_daily_views\nGROUP BY \n  TO_CHAR(tag, 'YYYY'),\n  TO_CHAR(tag, 'Day'),\n  EXTRACT(DOW FROM tag)\nORDER BY\n  EXTRACT(DOW FROM tag)\n)\nSELECT\n  year,\n  daily_views,\n  day,\n  dow\nFROM\n  cte_result\nUNION ALL\n-- In case there is no data we indicate it in the chart\nSELECT\n '2000' AS video_title,\n 0 AS daily_views,\n 'Sunday' AS week,\n 0 AS dow\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_result b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_result)",
            "refId": "A",
            "select": [
              [
                {
                  "params": [
                    "value"
                  ],
                  "type": "column"
                }
              ]
            ],
            "sql": {
              "columns": [
                {
                  "parameters": [],
                  "type": "function"
                }
              ],
              "groupBy": [
                {
                  "property": {
                    "type": "string"
                  },
                  "type": "groupBy"
                }
              ],
              "limit": 50
            },
            "timeColumn": "time",
            "where": [
              {
                "name": "$__timeFilter",
                "params": [],
                "type": "macro"
              }
            ]
          }
        ],
        "title": "Average Daily Views by Day of Week",
        "transparent": true,
        "type": "volkovlabs-echarts-panel"
      }
    ],
    "schemaVersion": 39,
    "tags": [
      "youtube",
      "channel"
    ],
    "templating": {
      "list": [
        {
          "current": {
            "selected": true,
            "text": [
              "Anitta",
              "Bad Bunny",
              "Feid",
              "Shakira"
            ],
            "value": [
              "Anitta",
              "Bad Bunny",
              "Feid",
              "Shakira"
            ]
          },
          "datasource": {
            "type": "postgres",
            "uid": "edk32zh8spnnke"
          },
          "definition": "WITH cte_channel_name AS (\nSELECT\n  channel_name\nFROM\n  youtube_stats.channel_info\nORDER BY\n  channel_name ASC\n)\nSELECT\n  channel_name\nFROM\n  cte_channel_name\nUNION ALL\nSELECT\n 'no data' AS channel_name\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_name b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_name)",
          "hide": 0,
          "includeAll": true,
          "label": "Channel Name",
          "multi": true,
          "name": "channel_info__channel_name",
          "options": [],
          "query": "WITH cte_channel_name AS (\nSELECT\n  channel_name\nFROM\n  youtube_stats.channel_info\nORDER BY\n  channel_name ASC\n)\nSELECT\n  channel_name\nFROM\n  cte_channel_name\nUNION ALL\nSELECT\n 'no data' AS channel_name\nFROM\n  (SELECT 1) a\nLEFT JOIN\n  cte_channel_name b ON FALSE\nWHERE\n  NOT EXISTS (SELECT 1 FROM cte_channel_name)",
          "refresh": 1,
          "regex": "",
          "skipUrlSync": false,
          "sort": 0,
          "type": "query"
        }
      ]
    },
    "time": {
      "from": "now-1y/d",
      "to": "now/d"
    },
    "timepicker": {
      "hidden": false
    },
    "timezone": "",
    "title": "Youtube Channel Analysis Advanced",
    "uid": "tBmXHiaIz",
    "version": 35,
    "weekStart": ""
  },
  "folderUid": "",
  "overwrite": true
}
